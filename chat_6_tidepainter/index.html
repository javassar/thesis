<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tidepainter: Songs of the Shore</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #f2e2b8;
      color: #1b3a4b;
      font-family: "Trebuchet MS", Verdana, sans-serif;
      overflow: hidden;
    }
    #game-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <script>
    const WIDTH = 960;
    const HEIGHT = 600;
    const TILE_SIZE = 32;
    const GRID_COLS = 23;
    const GRID_ROWS = 15;
    const GRID_ORIGIN_X = 224;
    const GRID_ORIGIN_Y = 48;
    const GRID_WIDTH = GRID_COLS * TILE_SIZE;
    const GRID_HEIGHT = GRID_ROWS * TILE_SIZE;
    const SEA_BAND_WIDTH = 200;

    const MAX_WAVES = 12;
    const CALM_DUR = {
      1: 4.8,
      2: 4.6,
      3: 4.4,
      4: 4.2,
      5: 4.2,
      6: 4.2,
      7: 4.2,
      8: 4.2,
      9: 4.2,
      10: 4.2,
      11: 4.2,
      12: 4.2
    };
    const WAVE_MAX = 3.0;
    const PACKETS_PER_SOURCE = 6;
    const SOURCE_VOL = 60;
    const SPEED = 256;
    const MATCH_TOL = 0.18;
    const REQUIRED_VOL = 60;
    const MIXER_TOKENS = 2;
    const MIXER_HOLD = 0.4;
    const TIDE_PULSE_WIDTH = 160;

    const COLORS = {
      skyTop: 0x87c6d8,
      skyBottom: 0xcfe9f2,
      sea: 0x63a6c3,
      beach: 0xf2e2b8,
      gridLine: 0xe3d3a5,
      grooveDark: 0xc2ab77,
      grooveMid: 0xd5bf8b,
      grooveEdge: 0xb89966,
      shellOutline: 0xcfb07f,
      coral: 0xe28f7b,
      coralOpen: 0xf2b7a5,
      ridge: 0x9c7a4f,
      filter: 0xf5f0e6,
      mixer: 0x7fb6d6,
      hud: 0x1b3a4b,
      hudSoft: 0x4a6572,
      tooltipBg: 0x1b3a4b
    };

    const TILE_TYPES = {
      SAND: 'Sand',
      GROOVE: 'Groove',
      SHELL: 'Shell',
      MIXER: 'RuneMixer',
      GATE: 'Gate'
    };

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function keyFor(col, row) {
      return `${col},${row}`;
    }

    function inBounds(col, row) {
      return col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS;
    }

    function tileCenter(col, row) {
      return {
        x: GRID_ORIGIN_X + col * TILE_SIZE + TILE_SIZE / 2,
        y: GRID_ORIGIN_Y + row * TILE_SIZE + TILE_SIZE / 2
      };
    }

    function colorDistance(a, b) {
      const dr = a[0] - b[0];
      const dg = a[1] - b[1];
      const db = a[2] - b[2];
      return Math.sqrt(dr * dr + dg * dg + db * db);
    }

    function mixColorsWeighted(c1, v1, c2, v2) {
      const total = v1 + v2;
      if (total <= 0) {
        return [0, 0, 0];
      }
      return [
        (c1[0] * v1 + c2[0] * v2) / total,
        (c1[1] * v1 + c2[1] * v2) / total,
        (c1[2] * v1 + c2[2] * v2) / total
      ];
    }

    function rgbToHex(rgb) {
      const r = clamp(Math.round(rgb[0] * 255), 0, 255);
      const g = clamp(Math.round(rgb[1] * 255), 0, 255);
      const b = clamp(Math.round(rgb[2] * 255), 0, 255);
      return (r << 16) + (g << 8) + b;
    }

    function directionFrom(c1, r1, c2, r2) {
      if (c2 > c1) return 'Right';
      if (c2 < c1) return 'Left';
      if (r2 > r1) return 'Down';
      return 'Up';
    }

    function ensureSkyTexture(scene) {
      if (scene.textures.exists('sky-grad')) return;
      const canvas = scene.textures.createCanvas('sky-grad', WIDTH, Math.floor(HEIGHT / 3));
      const ctx = canvas.context;
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#87C6D8');
      grad.addColorStop(1, '#CFE9F2');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      canvas.refresh();
    }

    function ensureTidePulseTexture(scene) {
      if (scene.textures.exists('tide-pulse')) return;
      const canvas = scene.textures.createCanvas('tide-pulse', TIDE_PULSE_WIDTH, GRID_HEIGHT);
      const ctx = canvas.context;
      const grad = ctx.createLinearGradient(0, 0, TIDE_PULSE_WIDTH, 0);
      grad.addColorStop(0, 'rgba(168, 208, 224, 0)');
      grad.addColorStop(0.5, 'rgba(210, 240, 255, 0.55)');
      grad.addColorStop(1, 'rgba(168, 208, 224, 0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      canvas.refresh();
    }

    function createStaticBackground(scene) {
      ensureSkyTexture(scene);
      scene.add.image(0, 0, 'sky-grad').setOrigin(0);
      scene.add.rectangle(SEA_BAND_WIDTH / 2, HEIGHT / 2, SEA_BAND_WIDTH, HEIGHT, COLORS.sea).setOrigin(0.5);
      scene.add.rectangle(SEA_BAND_WIDTH + (WIDTH - SEA_BAND_WIDTH) / 2, HEIGHT / 2 + HEIGHT / 6,
        WIDTH - SEA_BAND_WIDTH, HEIGHT * 2 / 3, COLORS.beach).setOrigin(0.5);
    }

    class TitleScene extends Phaser.Scene {
      constructor() {
        super('TitleScene');
      }

      create() {
        createStaticBackground(this);

        this.add.text(WIDTH / 2, 160, 'Tidepainter: Songs of the Shore', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '48px',
          color: '#1b3a4b'
        }).setOrigin(0.5);

        this.add.text(WIDTH / 2, 210, 'Carve paths, mix colors, open the gate.', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '20px',
          color: '#4a6572'
        }).setOrigin(0.5);

        const buttonBg = this.add.rectangle(WIDTH / 2, 300, 200, 56, 0xf7edd2, 1)
          .setStrokeStyle(2, 0x1b3a4b)
          .setInteractive({ useHandCursor: true });
        const buttonText = this.add.text(WIDTH / 2, 300, 'Play', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '22px',
          color: '#1b3a4b'
        }).setOrigin(0.5);

        this.add.text(WIDTH / 2, 360,
          'Drag to carve channels from buoys to shells.\nUse a Mixer to combine red+blue into purple for the gate.', {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '16px',
            color: '#4a6572',
            align: 'center'
          }).setOrigin(0.5);

        buttonBg.on('pointerdown', () => {
          this.scene.start('GameScene');
        });
      }
    }

    class EndScene extends Phaser.Scene {
      constructor() {
        super('EndScene');
      }

      init(data) {
        this.success = data.success;
        this.shellsFilled = data.shellsFilled || 0;
        this.wavesUsed = data.wavesUsed || MAX_WAVES;
      }

      create() {
        createStaticBackground(this);

        const mainText = this.success ? 'The shore sings your song.' : 'The tide carries your patterns away.';
        this.add.text(WIDTH / 2, 200, mainText, {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '36px',
          color: '#1b3a4b'
        }).setOrigin(0.5);

        this.add.text(WIDTH / 2, 260, `Shells filled: ${this.shellsFilled}/3`, {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '20px',
          color: '#4a6572'
        }).setOrigin(0.5);

        if (this.success) {
          this._sendComplete = () => {
            if (this._sentCompletion) return;
            this._sentCompletion = true;
            window.parent.postMessage({
              type: 'game-complete',
              data: {
                result: 'win',
                shellsFilled: this.shellsFilled,
                wavesUsed: this.wavesUsed
              }
            }, '*');
          };
          this.add.text(WIDTH / 2, 290, `Waves used: ${this.wavesUsed}/12`, {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '18px',
            color: '#4a6572'
          }).setOrigin(0.5);
        }

        const buttonBg = this.add.rectangle(WIDTH / 2, 360, 200, 56, 0xf7edd2, 1)
          .setStrokeStyle(2, 0x1b3a4b)
          .setInteractive({ useHandCursor: true });
        this.add.text(WIDTH / 2, 360, 'Replay', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '22px',
          color: '#1b3a4b'
        }).setOrigin(0.5);

        this.add.text(WIDTH / 2, 410, 'Press R to restart', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '16px',
          color: '#4a6572'
        }).setOrigin(0.5);

        buttonBg.on('pointerdown', () => {
          this.scene.start('GameScene');
        });

        this.keyR = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        this.keyEnter = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);

        if (this.success) {
          const continueBtn = this.add.text(WIDTH / 2, 460, 'Continue', {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '18px',
            color: '#1b3a4b'
          }).setOrigin(0.5).setInteractive({ useHandCursor: true });
          continueBtn.on('pointerdown', () => {
            if (this._sendComplete) {
              this._sendComplete();
            }
          });
        }
      }

      update() {
        if (Phaser.Input.Keyboard.JustDown(this.keyR)) {
          this.scene.start('GameScene');
        }
        if (this.success && Phaser.Input.Keyboard.JustDown(this.keyEnter)) {
          if (this._sendComplete) {
            this._sendComplete();
          }
        }
      }
    }

    class GameScene extends Phaser.Scene {
      constructor() {
        super('GameScene');
      }

      create() {
        createStaticBackground(this);

        this.seaWaveGraphics = this.add.graphics();
        this.gridGraphics = this.add.graphics();
        ensureTidePulseTexture(this);
        this.tidePulse = this.add.image(GRID_ORIGIN_X, GRID_ORIGIN_Y + GRID_HEIGHT / 2, 'tide-pulse')
          .setOrigin(0, 0.5)
          .setAlpha(0.55)
          .setVisible(false);
        this.packetGraphics = this.add.graphics();

        this.selectedTool = 'Carve';
        this.isPointerDown = false;
        this.lastDragTile = null;

        this.phase = 'Calm';
        this.waveIndex = 1;
        this.phaseTimer = CALM_DUR[this.waveIndex];
        this.waitingForFirstCarve = true;

        this.sources = [
          { row: 3, color: [1, 0, 0] },
          { row: 8, color: [0, 0, 1] }
        ];

        this.shells = [
          { col: 8, row: 3, target: [1, 0, 0], current: 0, required: REQUIRED_VOL, complete: false, lastColor: null, lastTimer: 0 },
          { col: 8, row: 8, target: [0, 0, 1], current: 0, required: REQUIRED_VOL, complete: false, lastColor: null, lastTimer: 0 },
          { col: 14, row: 5, target: [0.5, 0, 0.5], current: 0, required: REQUIRED_VOL, complete: false, lastColor: null, lastTimer: 0 }
        ];

        this.gate = {
          tile: { col: 11, row: 5 },
          inlet: { col: 10, row: 5 },
          required: [0.5, 0, 0.5],
          openNextWave: false,
          openThisWave: false,
          flashTimer: 0,
          unlocked: false
        };

        this.runeTokens = {
          mixers: MIXER_TOKENS
        };

        this.grid = [];
        for (let c = 0; c < GRID_COLS; c++) {
          const col = [];
          for (let r = 0; r < GRID_ROWS; r++) {
            col.push({
              type: TILE_TYPES.SAND,
              stability: 0
            });
          }
          this.grid.push(col);
        }

        this.shells.forEach(shell => {
          this.grid[shell.col][shell.row].type = TILE_TYPES.SHELL;
        });
        this.grid[this.gate.tile.col][this.gate.tile.row].type = TILE_TYPES.GATE;

        this.packets = [];
        this.mixerPools = {};
        this.flowGraph = {};

        this.wavesText = this.add.text(16, 12, 'Waves: 1/12', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '20px',
          color: '#1b3a4b'
        });

        this.phaseText = this.add.text(WIDTH / 2, 12, 'Phase: Calm', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '20px',
          color: '#1b3a4b'
        }).setOrigin(0.5, 0);

        this.tokensText = this.add.text(640, 12, 'Mixer: 2', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '20px',
          color: '#1b3a4b'
        });

        this.instructionText = this.add.text(16, 500,
          'Edit phase: carve paths and place Mixers.\nWave phase: paint follows grooves into matching shells.', {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '14px',
            color: '#4a6572'
          });

        this.controlsText = this.add.text(16, 532,
          'Tools: [1] Carve  [2] Mixer  [5] Erase', {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '13px',
            color: '#4a6572'
          });

        this.statusText = this.add.text(16, 562, '', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '13px',
          color: '#1b3a4b'
        });

        this.resetNotice = this.add.text(WIDTH / 2, HEIGHT / 2 - 10, 'Run reset. Try again!', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '20px',
          color: '#1b3a4b',
          backgroundColor: '#f7edd2',
          padding: { x: 12, y: 8 }
        }).setOrigin(0.5).setVisible(false);
        this.resetNoticeTimer = 0;

        this.tutorialText = this.add.text(WIDTH / 2, 480, '', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '16px',
          color: '#1b3a4b'
        }).setOrigin(0.5);

        this.legendTitle = this.add.text(748, 64, 'Targets:', {
          fontFamily: 'Trebuchet MS, Verdana, sans-serif',
          fontSize: '16px',
          color: '#1b3a4b'
        });
        this.legendItems = [
          this.add.text(748, 88, 'Red shell', { fontFamily: 'Trebuchet MS, Verdana, sans-serif', fontSize: '14px', color: '#c24a3a' }),
          this.add.text(748, 108, 'Blue shell', { fontFamily: 'Trebuchet MS, Verdana, sans-serif', fontSize: '14px', color: '#3a6db8' }),
          this.add.text(748, 128, 'Purple shell (behind gate)', { fontFamily: 'Trebuchet MS, Verdana, sans-serif', fontSize: '14px', color: '#6f4aa6' })
        ];

        this.gateHelpText = this.add.text(748, 156,
          'Gate: send purple into the\nmarked inlet tile (small ring)\nleft of the coral to open.', {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '13px',
            color: '#4a6572'
          });

        this.sourceHelpText = this.add.text(16, 64,
          'Buoys at left edge: carve from their rows\ninto the grid to start flow.', {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '13px',
            color: '#4a6572'
          });

        this.toolButtons = [];
        const toolDefs = [
          { tool: 'Carve', label: 'Carve [1]' },
          { tool: 'Mixer', label: 'Mixer [2]' },
          { tool: 'Erase', label: 'Erase [5]' }
        ];
        const startX = 16;
        const y = 544;
        toolDefs.forEach((def, index) => {
          const x = startX + index * 128;
          const rect = this.add.rectangle(x + 56, y + 20, 112, 40, 0xf7edd2, 1)
            .setStrokeStyle(2, 0x1b3a4b)
            .setInteractive({ useHandCursor: true });
          const text = this.add.text(x + 56, y + 20, def.label, {
            fontFamily: 'Trebuchet MS, Verdana, sans-serif',
            fontSize: '14px',
            color: '#1b3a4b'
          }).setOrigin(0.5);
          rect.on('pointerdown', () => {
            this.setTool(def.tool);
          });
          this.toolButtons.push({ tool: def.tool, rect, text });
        });

        this.keys = this.input.keyboard.addKeys({
          one: Phaser.Input.Keyboard.KeyCodes.ONE,
          two: Phaser.Input.Keyboard.KeyCodes.TWO,
          five: Phaser.Input.Keyboard.KeyCodes.FIVE
        });

        this.input.on('pointerdown', pointer => {
          if (this.phase !== 'Calm') return;
          const tile = this.pointerToTile(pointer);
          this.isPointerDown = !!tile;
          this.lastDragTile = null;
          if (tile) {
            this.handlePointerAction(pointer, true);
          }
        });

        this.input.on('pointerup', () => {
          this.isPointerDown = false;
          this.lastDragTile = null;
        });

        this.input.on('pointermove', pointer => {
          if (this.phase !== 'Calm') return;
          if (!this.isPointerDown) return;
          this.handlePointerAction(pointer, false);
        });

        this.setTool('Carve');
      }

      setTool(tool) {
        this.selectedTool = tool;
        this.toolButtons.forEach(btn => {
          if (btn.tool === tool) {
            btn.rect.setStrokeStyle(3, 0x1b3a4b);
          } else {
            btn.rect.setStrokeStyle(2, 0x1b3a4b);
          }
        });
      }

      handlePointerAction(pointer, isDown) {
        const tile = this.pointerToTile(pointer);
        if (!tile) return;
        const key = keyFor(tile.col, tile.row);
        if (!isDown && this.lastDragTile === key) {
          return;
        }
        this.lastDragTile = key;

        if (this.selectedTool === 'Carve') {
          this.applyCarve(tile.col, tile.row);
        } else if (this.selectedTool === 'Erase') {
          this.applyErase(tile.col, tile.row);
        } else if (this.selectedTool === 'Mixer' && isDown) {
          this.placeMixer(tile.col, tile.row);
        }
      }

      pointerToTile(pointer) {
        const x = pointer.worldX;
        const y = pointer.worldY;
        if (x < GRID_ORIGIN_X || y < GRID_ORIGIN_Y) return null;
        if (x >= GRID_ORIGIN_X + GRID_WIDTH || y >= GRID_ORIGIN_Y + GRID_HEIGHT) return null;
        const col = Math.floor((x - GRID_ORIGIN_X) / TILE_SIZE);
        const row = Math.floor((y - GRID_ORIGIN_Y) / TILE_SIZE);
        if (!inBounds(col, row)) return null;
        return { col, row };
      }

      isSourceEntry(col, row) {
        if (col !== 0) return false;
        return this.sources.some(source => source.row === row);
      }

      tileIsEditable(col, row) {
        const t = this.grid[col][row];
        if (t.type === TILE_TYPES.SHELL || t.type === TILE_TYPES.GATE) {
          return false;
        }
        return true;
      }

      applyCarve(col, row) {
        if (!this.tileIsEditable(col, row)) return;
        const t = this.grid[col][row];
        if (t.type === TILE_TYPES.SAND || t.type === TILE_TYPES.GROOVE) {
          t.type = TILE_TYPES.GROOVE;
          t.stability = 2;
          if (this.waveIndex === 1 && this.phase === 'Calm' && this.waitingForFirstCarve) {
            this.waitingForFirstCarve = false;
          }
        }
      }

      applyErase(col, row) {
        if (!this.tileIsEditable(col, row)) return;
        const t = this.grid[col][row];
        if (t.type === TILE_TYPES.GROOVE) {
          t.type = TILE_TYPES.SAND;
          t.stability = 0;
        } else if (t.type === TILE_TYPES.MIXER) {
          t.type = TILE_TYPES.SAND;
          this.runeTokens.mixers = Math.min(MIXER_TOKENS, this.runeTokens.mixers + 1);
        }
      }

      placeMixer(col, row) {
        if (!this.tileIsEditable(col, row)) return;
        const t = this.grid[col][row];
        if (t.type !== TILE_TYPES.SAND && t.type !== TILE_TYPES.GROOVE) return;
        if (this.runeTokens.mixers <= 0) return;
        this.runeTokens.mixers -= 1;
        t.type = TILE_TYPES.MIXER;
        t.stability = 0;
      }

      isPassableForFlow(col, row) {
        const t = this.grid[col][row];
        if (col === this.gate.inlet.col && row === this.gate.inlet.row) {
          return true;
        }
        if (t.type === TILE_TYPES.GROOVE || t.type === TILE_TYPES.SHELL || t.type === TILE_TYPES.MIXER) {
          return true;
        }
        if (t.type === TILE_TYPES.GATE) {
          return this.gate.openThisWave;
        }
        return this.isSourceEntry(col, row);
      }

      buildFlowGraph() {
        const graph = {};
        for (let c = 0; c < GRID_COLS; c++) {
          for (let r = 0; r < GRID_ROWS; r++) {
            if (!this.isPassableForFlow(c, r)) continue;
            const exits = [];
            const neighbors = [
              { col: c + 1, row: r },
              { col: c - 1, row: r },
              { col: c, row: r + 1 },
              { col: c, row: r - 1 }
            ];
            neighbors.forEach(n => {
              if (!inBounds(n.col, n.row)) return;
              if (!this.isPassableForFlow(n.col, n.row)) return;
              exits.push({ col: n.col, row: n.row });
            });
            graph[keyFor(c, r)] = exits;
          }
        }
        return graph;
      }

      startWave() {
        this.phase = 'Wave';
        this.phaseTimer = WAVE_MAX;
        this.packets = [];
        this.flowGraph = this.buildFlowGraph();
        this.mixerPools = {};
        this.gate.openThisWave = this.gate.unlocked || this.gate.openNextWave;
        this.gate.openNextWave = false;

        this.sources.forEach(source => {
          const entry = { col: 0, row: source.row };
          if (this.isPassableForFlow(entry.col, entry.row)) {
            for (let i = 0; i < PACKETS_PER_SOURCE; i++) {
              const center = tileCenter(entry.col, entry.row);
              this.packets.push({
                col: entry.col,
                row: entry.row,
                x: center.x,
                y: center.y,
                color: [...source.color],
                volume: SOURCE_VOL / PACKETS_PER_SOURCE,
                next: null,
                prevCol: null,
                prevRow: null
              });
            }
          }
        });
      }

      updateWave(dt) {
        Object.keys(this.mixerPools).forEach(key => {
          const pool = this.mixerPools[key];
          if (pool.bufferVol <= 0) return;
          pool.holdTimer -= dt;
          if (pool.holdTimer <= 0) {
            const [c, r] = key.split(',').map(Number);
            const center = tileCenter(c, r);
            this.packets.push({
              col: c,
              row: r,
              x: center.x,
              y: center.y,
              color: [...pool.bufferColor],
              volume: pool.bufferVol,
              next: null,
              prevCol: null,
              prevRow: null
            });
            pool.bufferVol = 0;
            pool.bufferColor = [0, 0, 0];
          }
        });

        for (let i = 0; i < this.packets.length; i++) {
          const packet = this.packets[i];
          if (packet.volume < 1) continue;
          let remaining = SPEED * dt;
          while (remaining > 0 && packet.volume > 0) {
            if (!packet.next) {
              const exits = this.flowGraph[keyFor(packet.col, packet.row)] || [];
              let usable = exits;
              if (packet.prevCol !== null && packet.prevRow !== null) {
                const filtered = exits.filter(ex => ex.col !== packet.prevCol || ex.row !== packet.prevRow);
                if (filtered.length > 0) {
                  usable = filtered;
                }
              }
              if (usable.length === 0) {
                packet.volume = 0;
                break;
              }
              if (usable.length > 1) {
                const per = packet.volume / usable.length;
                packet.volume = per;
                packet.next = usable[0];
                for (let j = 1; j < usable.length; j++) {
                  this.packets.push({
                    col: packet.col,
                    row: packet.row,
                    x: packet.x,
                    y: packet.y,
                    color: [...packet.color],
                    volume: per,
                    next: usable[j],
                    prevCol: packet.prevCol,
                    prevRow: packet.prevRow
                  });
                }
              } else {
                packet.next = usable[0];
              }
            }

            const target = tileCenter(packet.next.col, packet.next.row);
            const dx = target.x - packet.x;
            const dy = target.y - packet.y;
            const dist = Math.hypot(dx, dy);
            if (dist <= remaining) {
              packet.x = target.x;
              packet.y = target.y;
              remaining -= dist;
              packet.prevCol = packet.col;
              packet.prevRow = packet.row;
              packet.col = packet.next.col;
              packet.row = packet.next.row;
              packet.next = null;
              this.applyTileEffects(packet);
            } else {
              const ratio = remaining / dist;
              packet.x += dx * ratio;
              packet.y += dy * ratio;
              remaining = 0;
            }
          }
        }

        this.mergePackets();
        this.packets = this.packets.filter(packet => packet.volume >= 1);
      }

      mergePackets() {
        const buckets = {};
        const merged = [];
        this.packets.forEach(packet => {
          if (packet.volume < 1) return;
          if (packet.next) {
            merged.push(packet);
            return;
          }
          const key = keyFor(packet.col, packet.row);
          if (!buckets[key]) {
            buckets[key] = { packet: { ...packet }, total: packet.volume };
            merged.push(buckets[key].packet);
          } else {
            const entry = buckets[key];
            const total = entry.total + packet.volume;
            const color = mixColorsWeighted(entry.packet.color, entry.total, packet.color, packet.volume);
            entry.packet.color = color;
            entry.packet.volume = total;
            entry.total = total;
          }
        });
        this.packets = merged;
      }

      applyTileEffects(packet) {
        const tile = this.grid[packet.col][packet.row];
        if (tile.type === TILE_TYPES.MIXER) {
          const key = keyFor(packet.col, packet.row);
          if (!this.mixerPools[key]) {
            this.mixerPools[key] = { bufferVol: 0, bufferColor: [0, 0, 0], holdTimer: 0 };
          }
          const pool = this.mixerPools[key];
          if (pool.bufferVol === 0) {
            pool.bufferColor = [...packet.color];
          } else {
            pool.bufferColor = mixColorsWeighted(pool.bufferColor, pool.bufferVol, packet.color, packet.volume);
          }
          pool.bufferVol += packet.volume;
          pool.holdTimer = MIXER_HOLD;
          packet.volume = 0;
        } else if (tile.type === TILE_TYPES.SHELL) {
          this.deliverToShell(packet);
          packet.volume = 0;
        }

        if (packet.col === this.gate.inlet.col && packet.row === this.gate.inlet.row) {
          if (colorDistance(packet.color, this.gate.required) <= MATCH_TOL) {
            this.gate.openNextWave = true;
            this.gate.flashTimer = 0.6;
            this.gate.unlocked = true;
            this.gate.openThisWave = true;
            this.flowGraph = this.buildFlowGraph();
          }
        }
      }

      deliverToShell(packet) {
        const shell = this.shells.find(s => s.col === packet.col && s.row === packet.row);
        if (!shell || shell.complete) return;
        shell.lastColor = [...packet.color];
        shell.lastTimer = 0.8;
        if (colorDistance(packet.color, shell.target) <= MATCH_TOL) {
          const needed = shell.required - shell.current;
          const inc = Math.min(packet.volume, needed);
          shell.current += inc;
          if (shell.current >= shell.required) {
            shell.complete = true;
            this.playShellChord(shell);
          }
        }
      }

      endWave() {
        const shellsFilled = this.shells.filter(s => s.complete).length;
        if (shellsFilled === this.shells.length) {
          this.scene.start('EndScene', { success: true, shellsFilled, wavesUsed: this.waveIndex });
          return;
        }
        if (this.waveIndex >= MAX_WAVES) {
          this.resetRun();
          return;
        }
        this.waveIndex += 1;
        this.phase = 'Calm';
        this.phaseTimer = CALM_DUR[this.waveIndex];
      }

      resetRun() {
        this.waveIndex = 1;
        this.phase = 'Calm';
        this.phaseTimer = CALM_DUR[this.waveIndex];
        this.waitingForFirstCarve = true;
        this.packets = [];
        this.mixerPools = {};
        this.flowGraph = {};
        this.gate.openNextWave = false;
        this.gate.openThisWave = false;
        this.gate.flashTimer = 0;
        this.gate.unlocked = false;
        this.runeTokens.mixers = MIXER_TOKENS;

        for (let c = 0; c < GRID_COLS; c++) {
          for (let r = 0; r < GRID_ROWS; r++) {
            this.grid[c][r].type = TILE_TYPES.SAND;
            this.grid[c][r].stability = 0;
          }
        }

        this.shells.forEach(shell => {
          shell.current = 0;
          shell.complete = false;
          shell.lastColor = null;
          shell.lastTimer = 0;
          this.grid[shell.col][shell.row].type = TILE_TYPES.SHELL;
        });

        this.grid[this.gate.tile.col][this.gate.tile.row].type = TILE_TYPES.GATE;
        this.setTool('Carve');

        this.resetNotice.setVisible(true);
        this.resetNoticeTimer = 2.5;
      }

      playShellChord() {
        // Optional audio hook.
      }

      update(time, delta) {
        const dt = delta / 1000;

        if (Phaser.Input.Keyboard.JustDown(this.keys.one)) this.setTool('Carve');
        if (Phaser.Input.Keyboard.JustDown(this.keys.two)) this.setTool('Mixer');
        if (Phaser.Input.Keyboard.JustDown(this.keys.five)) this.setTool('Erase');

        if (this.phase === 'Calm') {
          if (this.waitingForFirstCarve) {
            // Pause the first countdown until the player carves from a buoy row.
          } else {
            this.phaseTimer -= dt;
            if (this.phaseTimer <= 0) {
              this.startWave();
            }
          }
        } else if (this.phase === 'Wave') {
          this.phaseTimer -= dt;
          this.updateWave(dt);
          const hasBuffered = Object.values(this.mixerPools).some(pool => pool.bufferVol > 0);
          if (this.phaseTimer <= 0 || (this.packets.length === 0 && !hasBuffered)) {
            this.endWave();
          }
        }

        if (this.gate.flashTimer > 0) {
          this.gate.flashTimer -= dt;
        }

        this.shells.forEach(shell => {
          if (shell.lastTimer > 0) {
            shell.lastTimer -= dt;
          }
        });
        if (this.resetNoticeTimer > 0) {
          this.resetNoticeTimer -= dt;
          if (this.resetNoticeTimer <= 0) {
            this.resetNotice.setVisible(false);
          }
        }

        this.updateHud();
        this.drawSeaWaves(time);
        this.drawGridAndTiles();
        this.updateTidePulse();
        this.drawPackets();
      }

      updateHud() {
        this.wavesText.setText(`Waves: ${this.waveIndex}/12`);
        if (this.phase === 'Calm') {
          if (this.waitingForFirstCarve) {
            this.phaseText.setText('Phase: Calm | Waiting for first carve');
          } else {
            this.phaseText.setText(`Phase: Calm | Wave in: ${this.phaseTimer.toFixed(1)}s`);
          }
        } else if (this.phase === 'Wave') {
          this.phaseText.setText(`Phase: Wave | Time left: ${Math.max(0, this.phaseTimer).toFixed(1)}s`);
        }
        this.tokensText.setText(`Mixer: ${this.runeTokens.mixers}`);
        this.statusText.setText(`Selected: ${this.selectedTool}`);

        if (this.waveIndex <= 4) {
          const message = this.waveIndex === 1
            ? 'Step 1: Carve from the left buoy rows into the grid.'
            : this.waveIndex === 2
              ? 'Step 2: Place a Mixer where red and blue meet.'
              : this.waveIndex === 3
                ? 'Step 3: Send purple into the inlet (small ring) to open the gate.'
                : 'Step 4: Fill the purple shell behind the gate.';
          this.tutorialText.setText(message);
          if (this.waveIndex === 1 && this.waitingForFirstCarve) {
            this.statusText.setText('Carve any groove to begin the first wave.');
          }
        } else {
          this.tutorialText.setText('');
        }
      }

      updateTidePulse() {
        if (!this.tidePulse) return;
        if (this.phase !== 'Wave') {
          this.tidePulse.setVisible(false);
          return;
        }
        const progress = clamp(1 - this.phaseTimer / WAVE_MAX, 0, 1);
        const span = GRID_WIDTH + TIDE_PULSE_WIDTH;
        const x = GRID_ORIGIN_X - TIDE_PULSE_WIDTH + span * progress;
        const alpha = 0.35 + 0.25 * Math.sin(progress * Math.PI);
        this.tidePulse.setVisible(true);
        this.tidePulse.setPosition(x, GRID_ORIGIN_Y + GRID_HEIGHT / 2);
        this.tidePulse.setAlpha(alpha);
      }

      drawSeaWaves(time) {
        const t = time * 0.002;
        this.seaWaveGraphics.clear();
        this.seaWaveGraphics.lineStyle(1, 0xa8d0e0, 0.5);
        for (let i = 0; i < 8; i++) {
          const y = 30 + i * 70 + Math.sin(t + i * 0.6) * 6;
          this.seaWaveGraphics.beginPath();
          this.seaWaveGraphics.moveTo(12, y);
          this.seaWaveGraphics.lineTo(SEA_BAND_WIDTH - 12, y);
          this.seaWaveGraphics.strokePath();
        }
      }

      drawGridAndTiles() {
        this.gridGraphics.clear();
        this.gridGraphics.lineStyle(1, COLORS.gridLine, 0.6);
        for (let c = 0; c <= GRID_COLS; c++) {
          const x = GRID_ORIGIN_X + c * TILE_SIZE;
          this.gridGraphics.beginPath();
          this.gridGraphics.moveTo(x, GRID_ORIGIN_Y);
          this.gridGraphics.lineTo(x, GRID_ORIGIN_Y + GRID_HEIGHT);
          this.gridGraphics.strokePath();
        }
        for (let r = 0; r <= GRID_ROWS; r++) {
          const y = GRID_ORIGIN_Y + r * TILE_SIZE;
          this.gridGraphics.beginPath();
          this.gridGraphics.moveTo(GRID_ORIGIN_X, y);
          this.gridGraphics.lineTo(GRID_ORIGIN_X + GRID_WIDTH, y);
          this.gridGraphics.strokePath();
        }

        for (let c = 0; c < GRID_COLS; c++) {
          for (let r = 0; r < GRID_ROWS; r++) {
            const tile = this.grid[c][r];
            const x = GRID_ORIGIN_X + c * TILE_SIZE;
            const y = GRID_ORIGIN_Y + r * TILE_SIZE;
            const center = tileCenter(c, r);

            if (tile.type === TILE_TYPES.GROOVE) {
              const color = tile.stability >= 2 ? COLORS.grooveDark : COLORS.grooveMid;
              this.gridGraphics.fillStyle(color, 0.9);
              this.gridGraphics.fillRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6);
              this.gridGraphics.lineStyle(1, COLORS.grooveEdge, 0.6);
              this.gridGraphics.strokeRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6);
            } else if (tile.type === TILE_TYPES.MIXER) {
              this.gridGraphics.fillStyle(COLORS.mixer, 0.7);
              this.gridGraphics.fillCircle(center.x, center.y, 12);
              this.gridGraphics.lineStyle(1, 0x6fa3c0, 0.8);
              this.gridGraphics.strokeCircle(center.x, center.y, 12);
            } else if (tile.type === TILE_TYPES.SHELL) {
              const shell = this.shells.find(s => s.col === c && s.row === r);
              if (shell) {
                this.gridGraphics.lineStyle(2, COLORS.shellOutline, 1);
                this.gridGraphics.strokeCircle(center.x, center.y, 12);
                this.gridGraphics.lineStyle(4, 0xe9ddc0, 0.8);
                this.gridGraphics.strokeCircle(center.x, center.y, 12);
                const progress = clamp(shell.current / shell.required, 0, 1);
                this.gridGraphics.lineStyle(4, rgbToHex(shell.target), 1);
                this.gridGraphics.beginPath();
                this.gridGraphics.arc(center.x, center.y, 12, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress, false);
                this.gridGraphics.strokePath();
                this.gridGraphics.fillStyle(rgbToHex(shell.target), 0.9);
                this.gridGraphics.fillCircle(center.x, center.y, 4);
                if (shell.lastTimer > 0 && shell.lastColor) {
                  const glow = clamp(shell.lastTimer / 0.8, 0, 1);
                  this.gridGraphics.lineStyle(2, rgbToHex(shell.lastColor), 0.7 * glow);
                  this.gridGraphics.strokeCircle(center.x, center.y, 16 + (1 - glow) * 6);
                  this.gridGraphics.fillStyle(rgbToHex(shell.lastColor), 1);
                  this.gridGraphics.fillRect(center.x + 8, center.y - 14, 8, 8);
                }
              }
            } else if (tile.type === TILE_TYPES.GATE) {
              const isOpen = this.gate.openThisWave;
              const color = isOpen ? COLORS.coralOpen : COLORS.coral;
              const alpha = isOpen ? 0.6 : 1;
              this.gridGraphics.fillStyle(color, alpha);
              this.gridGraphics.fillRect(x + 4, y + 6, TILE_SIZE - 8, TILE_SIZE - 12);
              this.gridGraphics.lineStyle(2, 0xc96f5c, 0.8);
              this.gridGraphics.strokeRect(x + 4, y + 6, TILE_SIZE - 8, TILE_SIZE - 12);
              if (this.gate.flashTimer > 0) {
                this.gridGraphics.lineStyle(2, 0xffffff, 0.8);
                this.gridGraphics.strokeRect(x + 2, y + 4, TILE_SIZE - 4, TILE_SIZE - 8);
              }
            }

          }
        }

        const inletCenter = tileCenter(this.gate.inlet.col, this.gate.inlet.row);
        this.gridGraphics.lineStyle(2, 0xffffff, 0.8);
        this.gridGraphics.strokeCircle(inletCenter.x, inletCenter.y, 10);
        this.gridGraphics.fillStyle(0xf2b7a5, 0.7);
        this.gridGraphics.fillCircle(inletCenter.x, inletCenter.y, 4);

        this.sources.forEach(source => {
          const center = tileCenter(0, source.row);
          const buoyX = SEA_BAND_WIDTH / 2;
          this.gridGraphics.fillStyle(rgbToHex(source.color), 1);
          this.gridGraphics.fillCircle(buoyX, center.y, 10);
          this.gridGraphics.lineStyle(2, 0xffffff, 0.8);
          this.gridGraphics.strokeCircle(buoyX, center.y, 10);
        });
      }

      drawPackets() {
        this.packetGraphics.clear();
        this.packets.forEach(packet => {
          if (packet.volume < 1) return;
          this.packetGraphics.fillStyle(rgbToHex(packet.color), 0.9);
          this.packetGraphics.fillCircle(packet.x, packet.y, 5);
        });
      }

    }

    const config = {
      type: Phaser.AUTO,
      width: WIDTH,
      height: HEIGHT,
      parent: 'game-container',
      backgroundColor: '#f2e2b8',
      scene: [TitleScene, GameScene, EndScene],
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    new Phaser.Game(config);
  </script>
</body>
</html>
