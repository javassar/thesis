================================================================================
                    DON'T MAKE A SOUND - GAME DESIGN DOCUMENT
                              (REVISED CREATIVE DESIGN)
================================================================================

================================================================================
STAGE 1: GAME DESIGN
================================================================================

--------------------------------------------------------------------------------
1. TITLE & HOOK
--------------------------------------------------------------------------------

Title: DON'T MAKE A SOUND

One-sentence pitch: A horror game where YOU are the monster—your cursor makes 
noise, and the creatures hunting you can hear every nervous twitch of your hand.

--------------------------------------------------------------------------------
2. CORE INSIGHT
--------------------------------------------------------------------------------

Central Question: What if your fear itself was the danger?

The game explores the recursive trap of anxiety: the more afraid you are, the 
more you tremble. The more you tremble, the more noise your cursor makes. The 
more noise you make, the more the creatures hunt you. The more they hunt you, 
the more afraid you become. This is not a metaphor laid onto the game—it IS 
the game. Your nervous system is the difficulty setting.

Why This Matters: Horror games typically generate fear through content (monsters, 
gore, jump scares). This game generates fear through INTERFACE. The horror 
emerges from your own body's betrayal. Every player's experience is unique 
because it's calibrated to their individual anxiety response. Calm players 
find it manageable. Nervous players find it terrifying. The game is a mirror.

This creates genuine emotional stakes that most games lack: you're not just 
controlling a character, you're controlling YOURSELF. The cursor is not an 
abstraction—it's your actual hand. When you fail, you didn't make a tactical 
error; your body failed you. This collapses the distance between player and 
game in a way that's rarely achieved.

--------------------------------------------------------------------------------
3. MECHANIC-THEME INTEGRATION
--------------------------------------------------------------------------------

Primary Mechanics:

1. CHARACTER MOVEMENT (Keyboard - WASD):
   Your character moves through dark environments. This is standard. You control 
   where they go.

2. CURSOR NOISE (Mouse):
   Your cursor is ALWAYS visible on screen. It emits a faint glow. When you 
   move the mouse, sound waves ripple outward from the cursor's position. The 
   faster you move the cursor, the louder and farther the waves travel.

3. CREATURE RESPONSE:
   Eyeless creatures patrol the space. They cannot see. They hunt by sound. 
   When sound waves reach them, they turn and move toward the source. If they 
   reach your CHARACTER, the level restarts. If they reach your CURSOR... 
   nothing happens. The cursor is incorporeal. But it keeps making noise.

How This Embodies the Theme:

The mechanic creates a split-attention puzzle that becomes psychological horror:
- Your LEFT hand moves your character toward the goal
- Your RIGHT hand (cursor) must stay PERFECTLY STILL to avoid alerting creatures

But here's the key insight: staying still is hard when you're scared. The game 
weaponizes your own startle response. When a creature gets close, you flinch. 
When you flinch, your cursor moves. When your cursor moves, it makes noise. 
When it makes noise, the creature comes closer.

The game doesn't tell you to be afraid. It makes your fear into a concrete, 
measurable, consequential thing. This is what makes it genuinely creative: 
the mechanic isn't ABOUT fear, it PRODUCES fear through its own feedback loop.

Advanced Mechanic - Strategic Noise:

Crucially, noise isn't only bad. You can DELIBERATELY move your cursor to 
create distractions. Lure a creature to one side of the room, then move your 
character past while it investigates. This transforms the cursor from liability 
to tool—but using it requires accepting risk. Every intentional noise might 
spiral into panic if a creature responds faster than expected.

--------------------------------------------------------------------------------
4. PLAYER JOURNEY
--------------------------------------------------------------------------------

OPENING (0:00 - 0:45):
The screen is dark. Text fades in: "They can't see you." Pause. "They can 
hear everything." The text fades. A small figure appears in a dim room—your 
character. Your cursor is visible, surrounded by a soft glow. The exit door 
glows faintly on the opposite side.

You move your character. Silent. You move your cursor experimentally. Ripples 
of sound emanate outward, visualized as expanding rings. They fade at the 
walls. You reach the exit. Level complete.

Feeling: Introduction. Understanding. "Okay, I get it—don't move the mouse."

LEARNING (0:45 - 1:30):
Level 2 introduces a creature. It stands motionless in the center of the room. 
You must cross. If you bump your mouse, the ripples reach it. Its head snaps 
toward the sound. It moves toward where the noise originated. You freeze. It 
stops. It listens. It returns to patrolling.

You learn: movement attracts them, but they're hunting SOUND LOCATION, not you 
directly. If you make noise in one spot and move your character elsewhere, 
you're safe. Unless you make MORE noise.

Level 3: The room is larger. Two creatures patrol different paths. You must 
cross without alerting either. The margins are tighter. You become aware of 
your own hand. Is it steady? You think about your heartbeat. You notice your 
grip on the mouse. The self-awareness is uncomfortable.

Feeling: Growing tension. Metacognition. "I'm watching myself now."

DEVELOPMENT (1:30 - 3:00):
Level 4: A narrow corridor. A creature blocks the only path. You MUST use 
noise strategically. Move the cursor to one side, let the creature investigate, 
then slip past. But you have to be willing to make sound on purpose. This 
requires trust in the system—and in your own ability to then BE STILL.

Level 5: Multiple rooms connected by doors. Creatures patrol different rooms. 
You can hear them through walls (faint shuffling). Sound travels through 
doorways. A noise in one room can attract creatures from the next. The space 
feels claustrophobic despite being larger. You start routing: "If I make 
noise HERE, it pulls that one LEFT, then I can..."

Level 6: A creature starts NEAR you. Very near. You must move your character 
immediately—but if your cursor moves at all, it hears you. This is the first 
genuine test of nerve. Can you move your left hand without moving your right? 
You discover muscles you didn't know were connected.

Feeling: Escalating challenge. Strategic thinking emerging. Occasional panic.

ESCALATION (3:00 - 4:15):
Level 7: Darkness. Your character has a tiny radius of visibility. Your cursor 
glow is the only other light. Creatures are heard but not seen until close. 
The soundscape becomes crucial—you hear shuffling, breathing, the scrape of 
movement. You must navigate by ear while keeping your hand still.

Level 8: The "Chase" level. You begin already detected. A creature is moving 
toward your character. You must flee while resisting the urge to panic-move 
your mouse. The instinct to flail is overwhelming. Every flinch makes noise. 
Every noise draws more attention. You either find calm in chaos or you don't.

Feeling: Peak tension. Survival mode. Adrenaline.

CLIMAX (4:15 - 4:45):
Level 9 - "Silence": The final room. Multiple creatures. Complex layout. But 
there's something different: your cursor glow begins to fade. The sound radius 
of your movements decreases. You're learning to be truly quiet. The creatures 
seem less responsive—or are you just better at this now?

You navigate the final maze. You reach the exit. A creature stands beside it, 
unmoving. You pass inches from its eyeless face. Your hand doesn't shake. 
You exit.

RESOLUTION (4:45 - 5:00):
The screen brightens slightly. Your character steps into soft light—outside, 
finally. The cursor glow extinguishes entirely. Text fades in:

"Some fears are louder than others."

Pause.

"You learned to quiet yours."

The screen gently fades to white. No score. No ranking. Just the knowledge 
that you did something difficult, and your own body was the obstacle.

Feeling: Relief. Accomplishment. A strange, earned calm.

--------------------------------------------------------------------------------
5. GAME ELEMENTS
--------------------------------------------------------------------------------

THE SURVIVOR (Player Character)
- Small humanoid silhouette, 32x48 pixels
- Minimal detail—just enough to read as "person"
- Color: Dark gray (#3a3a3a) with subtle lighter outline
- Visibility radius: 150 pixels (dim light falloff)
- No face—the player projects themselves onto the figure
- Movement: 8-directional, constant speed
- No health, no inventory, no abilities beyond movement

THE CURSOR
- Always visible (cannot be hidden)
- Soft circular glow, 30-pixel radius
- Color: Pale blue (#8888cc), alpha 0.3
- When stationary: glow pulses very slightly (breathing effect)
- When moving: sound waves emit from cursor position
- Sound waves: expanding rings, color #6666aa, fade over 1.5 seconds
- Wave radius determined by cursor velocity (faster = larger waves)
- The cursor is incorporeal—creatures cannot "touch" it, only hear it

SOUND WAVES (Visual Representation of Noise)
- Concentric circles expanding from cursor position
- Speed of expansion: 200 pixels/second
- Max radius: 50-300 pixels depending on cursor velocity
- Color: starts #6666aa at alpha 0.4, fades to 0 as it expands
- Multiple waves can overlap (rapid mouse movement = many rings)
- Waves pass through walls but attenuate (reduced radius after passing)

THE LISTENERS (Creatures)
- Humanoid silhouettes, slightly larger than survivor (40x56 pixels)
- Color: Deep black (#0a0a0a) with subtle dark red outline (#2a1010)
- NO EYES—smooth head area where eyes would be
- Posture: slightly hunched, head tilted as if listening
- Idle animation: slow swaying, head movements (scanning for sound)
- Alert animation: head snaps toward sound source, body tenses
- Hunting animation: deliberate movement toward target, faster than patrol
- Sound: faint breathing/shuffling when close to player character

CREATURE STATES:
1. PATROL: Slow movement along preset path, head scanning
2. ALERT: Heard something. Stopped. Listening. Facing sound source.
3. HUNTING: Moving toward last known sound location
4. SEARCHING: Reached sound location, nothing there. Circling slowly.
5. RETURNING: Giving up, returning to patrol route

ENVIRONMENT
- Dark backgrounds, minimal detail
- Walls: Dark gray rectangles with subtle texture
- Floor: Slightly lighter gray, no texture
- Doors/Exits: Soft white glow, inviting contrast to the darkness
- Obstacles: Furniture silhouettes (tables, chairs, crates) - provide cover
- Overall aesthetic: oppressive darkness with islands of dim light

VISIBILITY SYSTEM
- Global darkness except for:
  - Player character's visibility radius (small, 150px)
  - Cursor glow (constant, 30px)
  - Exit glow (soft beacon)
  - Creature eyes would glow—but they have no eyes (this is unsettling)
- Creatures are visible when within player's light radius OR cursor glow radius
- Creatures outside visible range are heard, not seen (directional audio cues)

USER INTERFACE
- Absolutely minimal—horror relies on immersion
- Level number: Tiny "1/9" in top-left, color #333333, fades after 2 seconds
- No health bar, no score, no timer
- Restart: Press R (no visual prompt—player discovers this)
- On death: Screen flashes red-black, brief static sound, immediate restart
- No death animation for character—they simply vanish (implication is worse)

SCREENS:
- Title Screen: Black. "DON'T MAKE A SOUND" in white, slowly fading in and out 
  like breathing. "Click to begin" below, small. Cursor visible—already making 
  noise if moved. The game has already started teaching you.
- Game Levels: 1-9
- Ending Screen: Soft light. Character silhouette against brightness. Text.

AUDIO DESIGN (Critical to Experience):
- Ambient: Low, almost subliminal hum. Oppressive quiet.
- Cursor movement: Soft whoosh/hiss, volume scales with speed
- Sound waves hitting walls: Subtle echo
- Creature idle: Faint breathing, occasional shuffle (directional)
- Creature alert: Sharp intake of breath, head-snap sound
- Creature hunting: Footsteps, increasingly rapid as they close in
- Creature near player: Heartbeat begins (player's own heartbeat, implied)
- Death: Distorted static burst, cut to silence
- Level complete: Soft exhale sound, gentle tone
- Ending: Quiet, almost inaudible music—relief made sonic

--------------------------------------------------------------------------------
6. RULES & SYSTEMS
--------------------------------------------------------------------------------

PLAYER CONTROLS:
- WASD or Arrow Keys: Move character in 8 directions
- Mouse: Cursor position (always tracked, always consequential)
- R: Restart current level
- Escape: Pause (cursor movement still tracked—you can't escape yourself)
- Click: Advance from title screen; no other click functions

CHARACTER MOVEMENT:
- Speed: 150 pixels/second
- Acceleration: Instant (responsive controls for tension)
- No sprint, no abilities—purity of the core mechanic
- Character cannot move through walls or creatures
- Character collision with creature = level restart

CURSOR NOISE SYSTEM:
- Every frame, calculate cursor velocity (distance moved since last frame)
- If velocity > threshold (2 pixels), generate sound wave
- Sound wave radius = base (50px) + (velocity * 3), capped at 300px
- Waves expand from cursor's position at emission time
- Multiple waves from rapid movement create "noise trail"
- Waves last 1.5 seconds before fully fading

SOUND WAVE PHYSICS:
- Waves expand as circles
- When wave edge contacts wall: wave continues but radius is reduced by 40%
- Waves pass through doorways at full strength
- When wave edge contacts creature: creature enters ALERT state, faces wave origin

CREATURE BEHAVIOR STATE MACHINE:

PATROL (Default):
- Move along predefined path at slow speed (40 px/sec)
- Head sways side to side (listening animation)
- Transition to ALERT: Sound wave contacts creature

ALERT:
- Stop moving immediately
- Snap head toward sound wave origin point
- Listen for 1.5 seconds
- If another sound wave arrives during listen: Transition to HUNTING
- If no sound: Transition to RETURNING

HUNTING:
- Move toward last known sound origin at hunting speed (100 px/sec)
- If new sound wave arrives: update target to new origin
- If reach target location: Transition to SEARCHING
- If contact player character: KILL (level restart)

SEARCHING:
- Circle slowly around last known sound location
- Radius: 60 pixels, duration: 3 seconds
- If sound wave arrives during search: Transition to HUNTING
- If no sound: Transition to RETURNING

RETURNING:
- Move back toward patrol path at slow speed
- If sound wave arrives: Transition to ALERT
- If reach patrol path: Transition to PATROL

COLLISION RULES:
- Character + Creature = Death (instant level restart)
- Character + Wall = Blocked (no movement)
- Character + Exit = Level Complete
- Cursor + Anything = No collision (cursor is incorporeal)
- Sound Wave + Creature = Creature alerts/hunts

STRATEGIC NOISE (Deliberate Distraction):
- Player can intentionally move cursor to create noise elsewhere
- This lures creatures away from character's path
- Risk: Each noise might attract creatures toward cursor, creating more danger
- Skill expression: Knowing when to make noise vs. when to stay still

LEVEL PROGRESSION:
- Complete level 1 → automatic transition to level 2 (brief fade)
- Continue through level 9
- Complete level 9 → ending sequence
- Death at any level → restart that level (no progress loss)
- No saving—5-minute experience designed for single session

DIFFICULTY CURVE THROUGH LEVEL DESIGN:

Level 1: Empty room. Learn movement and cursor noise visualization.
Level 2: One creature, stationary. Learn that noise attracts.
Level 3: One creature, patrolling. Learn timing and patience.
Level 4: Creature blocking path. Learn deliberate distraction.
Level 5: Multiple rooms. Learn sound propagation and routing.
Level 6: Creature starts nearby. Learn immediate stillness under pressure.
Level 7: Darkness. Learn to navigate by sound.
Level 8: Chase scenario. Learn to stay calm while fleeing.
Level 9: Complex synthesis. Prove mastery.


================================================================================
STAGE 2: TECHNICAL IMPLEMENTATION PLAN
================================================================================

--------------------------------------------------------------------------------
7. TECHNICAL SPECIFICATION
--------------------------------------------------------------------------------

DISPLAY:
- Canvas size: 1024 x 768 pixels
- Background color: #0a0a0a (near-black)
- Rendering: Phaser graphics and sprites
- Lighting: Implemented via alpha masks or radial gradients

-------------------------

PLAYER CHARACTER (Survivor):

  Visual:
    - Rectangle silhouette: 32 wide x 48 tall
    - Color: #3a3a3a
    - Outline: 1px, color #4a4a4a
    - Optional subtle "breathing" scale animation (0.98-1.02, 2-second cycle)
  
  Light Radius:
    - Circle mask centered on character
    - Radius: 150 pixels
    - Falloff: Linear from full visibility at center to 0 at edge
    - Implementation: Radial gradient alpha mask
  
  Physics:
    - Collision body: Rectangle 28 wide x 44 tall (slightly smaller than visual)
    - Movement speed: 150 pixels/second
    - Movement: 8-directional, no acceleration
  
  Starting position: Defined per level

-------------------------

CURSOR:

  Visual:
    - Circle: 30 pixel radius
    - Color: #8888cc
    - Alpha: 0.3 base, pulses between 0.25-0.35 over 2-second cycle
    - Always rendered on top (highest z-index)
    - Soft edge (feathered 5px)
  
  Tracking:
    - Position updated every frame to match actual mouse position
    - Previous position stored for velocity calculation
  
  Velocity Calculation:
    - Each frame: velocity = distance(currentPos, previousPos)
    - Threshold for noise: velocity > 2 pixels
    - Max meaningful velocity: 50 pixels (anything above treated as 50)

-------------------------

SOUND WAVES:

  Generation:
    - When cursor velocity > 2: create new wave at cursor position
    - Wave spawns with radius 0, immediately begins expanding
  
  Visual:
    - Circle outline (not filled), stroke width 2px
    - Color: #6666aa
    - Alpha: starts at 0.4, decreases linearly as radius increases
    - Alpha = 0.4 * (1 - currentRadius / maxRadius)
  
  Properties:
    - Expansion speed: 200 pixels/second
    - Max radius: 50 + (cursorVelocity * 5), capped at 300
    - Lifespan: Determined by maxRadius / expansionSpeed (0.25 to 1.5 seconds)
  
  Wall Interaction:
    - When wave edge intersects wall: mark wave as "attenuated"
    - Attenuated waves have maxRadius reduced by 40% from point of contact
    - Visual: attenuated portion renders at 60% normal alpha
  
  Data Structure:
    - Each wave: {x, y, currentRadius, maxRadius, attenuated, birthTime}
    - Active waves stored in array, removed when currentRadius >= maxRadius

-------------------------

CREATURES (Listeners):

  Visual:
    - Rectangle silhouette: 40 wide x 56 tall
    - Color: #0a0a0a (pure dark)
    - Outline: 1px, color #2a1010 (subtle dark red)
    - Head area: Top 16 pixels, smooth (no eyes drawn)
    - Idle animation: Gentle sway (x offset oscillates ±3px, 3-second cycle)
    - Alert animation: Snap rotation toward sound (instant)
    - Hunting animation: Slight lean forward (5-degree tilt in movement direction)
  
  Physics:
    - Collision body: Rectangle 36 wide x 52 tall
    - Patrol speed: 40 pixels/second
    - Hunting speed: 100 pixels/second
    - Return speed: 50 pixels/second
  
  State Variables (per creature):
    - state: enum [PATROL, ALERT, HUNTING, SEARCHING, RETURNING]
    - patrolPath: array of {x, y} waypoints
    - patrolIndex: current waypoint index
    - targetPosition: {x, y} for hunting/searching
    - stateTimer: time remaining in current state (for ALERT, SEARCHING)
    - facingAngle: current facing direction (radians)
  
  Detection:
    - Each frame, check if any active sound wave's edge intersects creature's position
    - Intersection: wave's currentRadius is within 20px of distance(wave.origin, creature.position)
    - On detection: store wave.origin as soundSourcePosition

-------------------------

STATE MACHINE TIMING:

  PATROL:
    - No timer
    - Waypoint tolerance: 10 pixels (snap to next when within range)
  
  ALERT:
    - Duration: 1.5 seconds
    - If new sound detected during ALERT: immediate transition to HUNTING
    - If no sound: transition to RETURNING
  
  HUNTING:
    - No timer (continues until target reached or new sound)
    - Target reached tolerance: 30 pixels
    - On reaching target: transition to SEARCHING
  
  SEARCHING:
    - Duration: 3 seconds
    - Movement: Circle target position, radius 60 pixels
    - Circle speed: 40 pixels/second
    - On new sound: transition to HUNTING with new target
    - On timer complete: transition to RETURNING
  
  RETURNING:
    - No timer
    - Target: Nearest point on original patrol path
    - On reaching patrol path: transition to PATROL

-------------------------

ENVIRONMENT ELEMENTS:

  Walls:
    - Rectangles with collision
    - Color: #1a1a1a
    - Outline: 1px, color #252525
    - Block player movement
    - Attenuate (but don't block) sound waves
  
  Exits:
    - Rectangle: 60 wide x 80 tall (doorway shape)
    - Color: #ffffff at alpha 0.1 (soft glow)
    - Glow radius: 100 pixels, alpha 0.05
    - Pulse animation: alpha oscillates 0.08-0.12, 2-second cycle
    - Collision: Triggers level complete
  
  Obstacles (cover):
    - Various rectangles representing furniture
    - Color: #151515
    - Block player movement
    - Block line of sight (for future expansion, not used in core)
    - Attenuate sound waves same as walls

-------------------------

VISIBILITY SYSTEM:

  Implementation via Darkness Overlay:
    - Full-screen rectangle, color #0a0a0a, alpha 0.95
    - This covers everything by default
    
  Light Holes (reveal what's beneath):
    - Player light: Radial gradient mask at player position, 150px radius
    - Cursor glow: Radial gradient mask at cursor position, 30px radius
    - Exit glow: Radial gradient mask at exit position, 100px radius
    
  Alternative Implementation (if masks complex):
    - Render visible elements only when within light radius
    - Calculate distance from player/cursor to each element
    - Render with alpha based on distance (closer = more visible)

-------------------------

AUDIO SPECIFICATIONS:

  Ambient:
    - Low drone, 60Hz base frequency
    - Volume: 0.1 (barely audible)
    - Loops continuously
  
  Cursor Movement:
    - Sound: Soft hiss/whoosh
    - Volume: 0.1 + (cursorVelocity / 50) * 0.3, max 0.4
    - Pitch: Increases slightly with velocity
    - Play continuously while cursor moving, stop 0.1s after cursor stops
  
  Creature Sounds:
    - Breathing (when visible): Volume based on distance, max 0.3
    - Alert gasp: Short sound, volume 0.4
    - Footsteps (when hunting): Rate increases with speed, volume 0.3
  
  Heartbeat:
    - Triggered when creature within 150 pixels of player
    - Rate: 60 + (150 - distance) BPM
    - Volume: 0.2 + (150 - distance) / 150 * 0.3
  
  Death:
    - Static burst: 0.3 seconds, volume 0.6
    - Cut to silence
  
  Level Complete:
    - Soft exhale: 0.5 seconds, volume 0.3
    - Gentle tone: 1 second, volume 0.2

-------------------------

LEVEL DATA STRUCTURE:

Each level contains:
- playerStart: {x, y}
- exit: {x, y, width, height}
- walls: array of {x, y, width, height}
- obstacles: array of {x, y, width, height}
- creatures: array of {
    startX, startY,
    patrolPath: [{x, y}, ...],  // Empty for stationary
    startState: "PATROL" or "ALERT"
  }

-------------------------

LEVEL SPECIFICATIONS:

Level 1 - "First Breath"
  playerStart: {x: 100, y: 384}
  exit: {x: 900, y: 352, width: 60, height: 80}
  walls: [
    {x: 0, y: 0, width: 1024, height: 20},      // top
    {x: 0, y: 748, width: 1024, height: 20},    // bottom
    {x: 0, y: 0, width: 20, height: 768},       // left
    {x: 1004, y: 0, width: 20, height: 768}     // right
  ]
  obstacles: []
  creatures: []
  // Purpose: Learn movement and see cursor noise visualization

Level 2 - "Listener"
  playerStart: {x: 100, y: 384}
  exit: {x: 900, y: 352, width: 60, height: 80}
  walls: [standard border walls]
  obstacles: []
  creatures: [
    {startX: 500, startY: 400, patrolPath: [], startState: "PATROL"}
  ]
  // Purpose: Learn that noise attracts; creature is stationary

Level 3 - "Patrol"
  playerStart: {x: 100, y: 680}
  exit: {x: 900, y: 80, width: 60, height: 80}
  walls: [
    standard border walls,
    {x: 300, y: 200, width: 400, height: 20}   // horizontal divider
  ]
  obstacles: [
    {x: 200, y: 500, width: 80, height: 80}    // cover
  ]
  creatures: [
    {startX: 500, startY: 400, 
     patrolPath: [{x: 300, y: 400}, {x: 700, y: 400}], 
     startState: "PATROL"}
  ]
  // Purpose: Learn timing, waiting for patrol to pass

Level 4 - "Distraction"
  playerStart: {x: 100, y: 384}
  exit: {x: 900, y: 352, width: 60, height: 80}
  walls: [
    standard border walls,
    {x: 400, y: 200, width: 20, height: 200},   // top vertical wall
    {x: 400, y: 500, width: 20, height: 200}    // bottom vertical wall
    // Gap in middle for passage
  ]
  obstacles: []
  creatures: [
    {startX: 500, startY: 384, patrolPath: [], startState: "PATROL"}
  ]
  // Purpose: Creature blocks only passage; must use noise to lure away

Level 5 - "Rooms"
  playerStart: {x: 80, y: 680}
  exit: {x: 920, y: 80, width: 60, height: 80}
  walls: [
    standard border walls,
    {x: 340, y: 0, width: 20, height: 300},
    {x: 340, y: 400, width: 20, height: 368},
    {x: 680, y: 0, width: 20, height: 200},
    {x: 680, y: 300, width: 20, height: 468}
  ]
  obstacles: [
    {x: 150, y: 300, width: 60, height: 60},
    {x: 500, y: 500, width: 80, height: 40}
  ]
  creatures: [
    {startX: 170, startY: 150, 
     patrolPath: [{x: 100, y: 150}, {x: 280, y: 150}],
     startState: "PATROL"},
    {startX: 500, startY: 300,
     patrolPath: [{x: 400, y: 300}, {x: 620, y: 300}],
     startState: "PATROL"}
  ]
  // Purpose: Multi-room navigation, sound travels through doorways

Level 6 - "Close"
  playerStart: {x: 100, y: 384}
  exit: {x: 900, y: 352, width: 60, height: 80}
  walls: [standard border walls]
  obstacles: [
    {x: 300, y: 300, width: 100, height: 100},
    {x: 500, y: 450, width: 80, height: 80},
    {x: 700, y: 280, width: 60, height: 120}
  ]
  creatures: [
    {startX: 200, startY: 384, patrolPath: [], startState: "PATROL"}
  ]
  // Purpose: Creature starts VERY close; immediate stillness required

Level 7 - "Darkness"
  playerStart: {x: 100, y: 680}
  exit: {x: 900, y: 80, width: 60, height: 80}
  walls: [
    standard border walls,
    {x: 200, y: 150, width: 200, height: 20},
    {x: 500, y: 300, width: 20, height: 200},
    {x: 300, y: 500, width: 250, height: 20},
    {x: 650, y: 200, width: 20, height: 250}
  ]
  obstacles: []
  creatures: [
    {startX: 300, startY: 350,
     patrolPath: [{x: 250, y: 300}, {x: 450, y: 400}, {x: 250, y: 450}],
     startState: "PATROL"},
    {startX: 750, startY: 500,
     patrolPath: [{x: 700, y: 400}, {x: 850, y: 550}],
     startState: "PATROL"}
  ]
  // Purpose: Reduced visibility (player light radius = 100); rely on sound

Level 8 - "Chase"
  playerStart: {x: 100, y: 384}
  exit: {x: 900, y: 384, width: 60, height: 80}
  walls: [
    standard border walls,
    // Maze-like structure
    {x: 200, y: 0, width: 20, height: 550},
    {x: 350, y: 200, width: 20, height: 568},
    {x: 500, y: 0, width: 20, height: 450},
    {x: 650, y: 300, width: 20, height: 468},
    {x: 800, y: 0, width: 20, height: 500}
  ]
  obstacles: []
  creatures: [
    {startX: 150, startY: 300,
     patrolPath: [],
     startState: "HUNTING"}   // Starts already hunting player position!
  ]
  // Purpose: Escape while being pursued; panic management

Level 9 - "Silence"
  playerStart: {x: 80, y: 700}
  exit: {x: 940, y: 60, width: 60, height: 80}
  walls: [
    standard border walls,
    {x: 200, y: 100, width: 20, height: 400},
    {x: 350, y: 250, width: 20, height: 518},
    {x: 500, y: 0, width: 20, height: 350},
    {x: 500, y: 450, width: 20, height: 318},
    {x: 650, y: 200, width: 20, height: 400},
    {x: 800, y: 0, width: 20, height: 500},
    {x: 800, y: 600, width: 20, height: 168}
  ]
  obstacles: [
    {x: 100, y: 550, width: 60, height: 60},
    {x: 420, y: 150, width: 50, height: 50},
    {x: 580, y: 550, width: 70, height: 40},
    {x: 720, y: 350, width: 50, height: 80}
  ]
  creatures: [
    {startX: 150, startY: 250,
     patrolPath: [{x: 100, y: 200}, {x: 100, y: 450}],
     startState: "PATROL"},
    {startX: 420, startY: 600,
     patrolPath: [{x: 280, y: 600}, {x: 480, y: 700}],
     startState: "PATROL"},
    {startX: 580, startY: 300,
     patrolPath: [{x: 540, y: 200}, {x: 620, y: 430}],
     startState: "PATROL"},
    {startX: 920, startY: 150,
     patrolPath: [],
     startState: "PATROL"}    // Stationary guard by exit
  ]
  // Purpose: Final synthesis; cursor noise radius reduced by 30% (reward for learning)

--------------------------------------------------------------------------------
8. GAME FLOW
--------------------------------------------------------------------------------

LAUNCH:
1. Phaser initializes (1024x768, arcade physics)
2. Load audio assets
3. Set gameState = "title"
4. Display title screen

TITLE SCREEN:
1. Black background
2. "DON'T MAKE A SOUND" text, breathing alpha animation
3. "Click to begin" text below
4. Cursor is visible and noise system is ACTIVE (teaching starts immediately)
5. Sound waves appear if player moves mouse—first lesson
6. On click:
   - Fade to black (0.5 seconds)
   - Set currentLevel = 1
   - Set gameState = "playing"
   - Load level 1

LEVEL LOAD:
1. Clear all existing game objects
2. Read level data for currentLevel
3. Create walls and obstacles with collision
4. Create darkness overlay
5. Create player at playerStart
6. Create exit with glow effect
7. Create creatures with initial states
8. Initialize sound wave array (empty)
9. Create light masks (player, cursor, exit)
10. Show level indicator briefly (fade out after 2 seconds)

MAIN GAME LOOP (every frame):

1. INPUT PHASE:
   - Record current cursor position
   - Calculate cursor velocity from previous frame
   - Check WASD/Arrow input
   - Check R key (restart)
   - Check Escape (pause toggle)

2. CURSOR NOISE PHASE:
   - If cursorVelocity > threshold:
     - Create new sound wave at cursor position
     - Calculate wave maxRadius based on velocity
     - Play cursor movement sound

3. SOUND WAVE UPDATE PHASE:
   - For each active wave:
     - Expand radius based on deltaTime
     - Check wall intersections, apply attenuation
     - Check creature intersections
     - If fully expanded: mark for removal
   - Remove expired waves
   - Render wave visuals

4. CREATURE UPDATE PHASE:
   - For each creature:
     - Check if any sound wave is intersecting
     - If yes: record sound source, process state transition
     - Execute current state behavior:
       - PATROL: Move toward next waypoint
       - ALERT: Count down timer, face sound source
       - HUNTING: Move toward target
       - SEARCHING: Circle target, count down timer
       - RETURNING: Move toward patrol path
     - Update visual (position, facing, animation state)
     - Check collision with player

5. PLAYER UPDATE PHASE:
   - Calculate movement direction from input
   - Apply movement (check wall collisions)
   - Update position
   - Update light mask position

6. COLLISION CHECK PHASE:
   - Player vs Exit: complete level
   - Player vs Creature: death

7. AUDIO UPDATE PHASE:
   - Update heartbeat based on nearest creature distance
   - Update creature sounds based on visibility/distance

8. RENDER PHASE:
   - Draw environment (walls, obstacles)
   - Draw exit glow
   - Draw creatures
   - Draw player
   - Draw sound waves
   - Draw darkness overlay with light holes
   - Draw cursor glow

DEATH:
1. Play death sound (static burst)
2. Flash screen red-black
3. Immediate restart (no delay, no animation)
4. Load current level again

LEVEL COMPLETE:
1. Play complete sound
2. Fade to black (0.3 seconds)
3. currentLevel++
4. If currentLevel > 9:
   - Display ending
5. Else:
   - Load next level
   - Fade in (0.3 seconds)

ENDING:
1. Fade to slightly brighter background (#1a1a2a)
2. Draw player silhouette at center
3. Gradual brightening over 2 seconds
4. Display "Some fears are louder than others." (fade in)
5. 2-second pause
6. Display "You learned to quiet yours." (fade in)
7. Wait for click
8. Return to title screen

--------------------------------------------------------------------------------
9. PSEUDOCODE
--------------------------------------------------------------------------------

// ============================================================================
// CONSTANTS
// ============================================================================

CONFIG = {
    width: 1024,
    height: 768,
    backgroundColor: 0x0a0a0a
}

PLAYER = {
    width: 32,
    height: 48,
    speed: 150,
    lightRadius: 150   // 100 in level 7
}

CURSOR = {
    glowRadius: 30,
    noiseThreshold: 2,        // minimum velocity to create sound
    noiseMultiplier: 5,       // velocity to radius conversion
    maxNoiseRadius: 300,
    minNoiseRadius: 50
}

WAVE = {
    expansionSpeed: 200,
    wallAttenuation: 0.6,     // multiply max radius by this on wall hit
    strokeWidth: 2,
    maxAlpha: 0.4
}

CREATURE = {
    width: 40,
    height: 56,
    patrolSpeed: 40,
    huntSpeed: 100,
    returnSpeed: 50,
    alertDuration: 1.5,       // seconds
    searchDuration: 3,        // seconds
    searchRadius: 60,
    detectionTolerance: 20    // pixels from wave edge
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

gameState = "title"
currentLevel = 1
isPaused = false

// Per-level state
player = null
creatures = []
soundWaves = []
walls = []
obstacles = []
exit = null

// Cursor tracking
cursorPosition = {x: 0, y: 0}
previousCursorPosition = {x: 0, y: 0}
cursorVelocity = 0

// ============================================================================
// MAIN SCENE
// ============================================================================

function preload():
    // Load audio
    loadAudio('ambient', 'ambient_drone.mp3')
    loadAudio('cursor_noise', 'whoosh.mp3')
    loadAudio('alert', 'gasp.mp3')
    loadAudio('footstep', 'footstep.mp3')
    loadAudio('heartbeat', 'heartbeat.mp3')
    loadAudio('death', 'static.mp3')
    loadAudio('complete', 'exhale.mp3')

function create():
    // Start ambient audio
    playLooping('ambient', volume: 0.1)
    
    // Initialize cursor tracking
    this.input.on('pointermove', updateCursorPosition)
    
    // Keyboard setup
    setupKeyboardInput()
    
    // Show title
    displayTitleScreen()

function update(time, delta):
    if gameState == "title":
        updateTitleScreen(delta)
        return
    
    if gameState == "ending":
        return
    
    if gameState == "playing" and not isPaused:
        updateGame(delta / 1000)

// ============================================================================
// TITLE SCREEN
// ============================================================================

function displayTitleScreen():
    gameState = "title"
    clearLevel()
    
    // Create title text with breathing animation
    titleText = createText(512, 350, "DON'T MAKE A SOUND", {
        fontFamily: "Georgia, serif",
        fontSize: 48,
        color: "#ffffff"
    })
    titleText.setOrigin(0.5)
    
    subtitleText = createText(512, 420, "Click to begin", {
        fontFamily: "Georgia, serif",
        fontSize: 20,
        color: "#444444"
    })
    subtitleText.setOrigin(0.5)
    
    // Enable cursor noise visualization even on title
    initializeCursorGlow()
    
    // Click handler
    this.input.once('pointerdown', startGame)

function updateTitleScreen(delta):
    // Breathing animation for title
    titleText.alpha = 0.7 + 0.3 * sin(time * 0.002)
    
    // Process cursor noise (teaching on title screen)
    processCursorNoise()
    updateSoundWaves(delta / 1000)

function startGame():
    fadeOut(500, function():
        currentLevel = 1
        loadLevel(currentLevel)
        gameState = "playing"
        fadeIn(300)
    )

// ============================================================================
// LEVEL MANAGEMENT
// ============================================================================

function loadLevel(levelNum):
    clearLevel()
    
    levelData = LEVELS[levelNum]
    
    // Create environment
    for each wallData in levelData.walls:
        wall = createRectangle(wallData.x, wallData.y, wallData.width, wallData.height, 0x1a1a1a)
        addStaticCollider(wall)
        walls.push(wall)
    
    for each obstacleData in levelData.obstacles:
        obstacle = createRectangle(obstacleData.x, obstacleData.y, obstacleData.width, obstacleData.height, 0x151515)
        addStaticCollider(obstacle)
        obstacles.push(obstacle)
    
    // Create exit
    exit = createExit(levelData.exit.x, levelData.exit.y, levelData.exit.width, levelData.exit.height)
    
    // Create player
    player = createPlayer(levelData.playerStart.x, levelData.playerStart.y)
    
    // Adjust light radius for level 7
    if levelNum == 7:
        player.lightRadius = 100
    else:
        player.lightRadius = PLAYER.lightRadius
    
    // Create creatures
    for each creatureData in levelData.creatures:
        creature = createCreature(creatureData)
        creatures.push(creature)
    
    // Create darkness overlay
    createDarknessOverlay()
    
    // Initialize cursor
    initializeCursorGlow()
    
    // Show level indicator
    showLevelIndicator(levelNum)
    
    // Clear sound waves
    soundWaves = []

function clearLevel():
    destroyAll(walls)
    destroyAll(obstacles)
    destroyAll(creatures)
    destroyAll(soundWaves)
    if player: player.destroy()
    if exit: exit.destroy()
    walls = []
    obstacles = []
    creatures = []
    soundWaves = []
    player = null
    exit = null

// ============================================================================
// MAIN GAME UPDATE
// ============================================================================

function updateGame(deltaTime):
    // Check restart key
    if keyJustPressed('R'):
        restartLevel()
        return
    
    // ---- CURSOR NOISE ----
    calculateCursorVelocity()
    processCursorNoise()
    
    // ---- SOUND WAVES ----
    updateSoundWaves(deltaTime)
    checkWaveCreatureIntersections()
    
    // ---- CREATURES ----
    for each creature in creatures:
        updateCreature(creature, deltaTime)
        
        if checkCollision(player, creature):
            playerDeath()
            return
    
    // ---- PLAYER ----
    handlePlayerInput()
    updatePlayerPosition(deltaTime)
    
    // ---- EXIT CHECK ----
    if checkCollision(player, exit):
        completeLevel()
        return
    
    // ---- AUDIO ----
    updateProximityAudio()
    
    // ---- RENDERING ----
    updateDarknessOverlay()
    updateCursorGlow()

// ============================================================================
// CURSOR AND SOUND WAVES
// ============================================================================

function updateCursorPosition(pointer):
    previousCursorPosition = {x: cursorPosition.x, y: cursorPosition.y}
    cursorPosition = {x: pointer.x, y: pointer.y}

function calculateCursorVelocity():
    dx = cursorPosition.x - previousCursorPosition.x
    dy = cursorPosition.y - previousCursorPosition.y
    cursorVelocity = sqrt(dx * dx + dy * dy)
    
    // Cap at meaningful maximum
    cursorVelocity = min(cursorVelocity, 50)

function processCursorNoise():
    if cursorVelocity > CURSOR.noiseThreshold:
        // Create sound wave
        maxRadius = CURSOR.minNoiseRadius + (cursorVelocity * CURSOR.noiseMultiplier)
        maxRadius = min(maxRadius, CURSOR.maxNoiseRadius)
        
        wave = {
            x: cursorPosition.x,
            y: cursorPosition.y,
            currentRadius: 0,
            maxRadius: maxRadius,
            attenuated: false,
            birthTime: getCurrentTime()
        }
        
        soundWaves.push(wave)
        
        // Play sound scaled to velocity
        volume = 0.1 + (cursorVelocity / 50) * 0.3
        playSound('cursor_noise', volume: volume)

function updateSoundWaves(deltaTime):
    for each wave in soundWaves:
        // Expand
        wave.currentRadius += WAVE.expansionSpeed * deltaTime
        
        // Check wall collisions (simplified: just reduce max radius once)
        if not wave.attenuated:
            for each wall in walls:
                if waveIntersectsRect(wave, wall):
                    wave.maxRadius = wave.maxRadius * WAVE.wallAttenuation
                    wave.attenuated = true
                    break
        
        // Calculate alpha
        wave.alpha = WAVE.maxAlpha * (1 - wave.currentRadius / wave.maxRadius)
        
        // Draw
        drawWaveRing(wave.x, wave.y, wave.currentRadius, wave.alpha)
    
    // Remove expired waves
    soundWaves = soundWaves.filter(w => w.currentRadius < w.maxRadius)

function waveIntersectsRect(wave, rect):
    // Check if circle edge intersects rectangle
    // Simplified: check if wave circle overlaps rectangle
    closestX = clamp(wave.x, rect.x, rect.x + rect.width)
    closestY = clamp(wave.y, rect.y, rect.y + rect.height)
    
    distance = dist(wave.x, wave.y, closestX, closestY)
    
    return distance <= wave.currentRadius

function checkWaveCreatureIntersections():
    for each creature in creatures:
        for each wave in soundWaves:
            // Check if wave edge is near creature
            distToCreature = dist(wave.x, wave.y, creature.x, creature.y)
            
            if abs(distToCreature - wave.currentRadius) < CREATURE.detectionTolerance:
                // Creature detected sound!
                creatureHearSound(creature, wave.x, wave.y)
                break  // Only react to first detected wave

// ============================================================================
// CREATURE AI
// ============================================================================

function createCreature(data):
    creature = {
        sprite: createCreatureSprite(data.startX, data.startY),
        x: data.startX,
        y: data.startY,
        state: data.startState,
        patrolPath: data.patrolPath,
        patrolIndex: 0,
        targetX: data.startX,
        targetY: data.startY,
        stateTimer: 0,
        facingAngle: 0
    }
    
    // If starting in HUNTING, target is player start position
    if creature.state == "HUNTING":
        creature.targetX = player.x
        creature.targetY = player.y
    
    return creature

function creatureHearSound(creature, soundX, soundY):
    creature.lastSoundX = soundX
    creature.lastSoundY = soundY
    
    // Update facing
    creature.facingAngle = atan2(soundY - creature.y, soundX - creature.x)
    
    if creature.state == "PATROL" or creature.state == "RETURNING":
        creature.state = "ALERT"
        creature.stateTimer = CREATURE.alertDuration
        playSound('alert', volume: 0.4)
    
    else if creature.state == "ALERT":
        // Sound during alert = immediately hunt
        creature.state = "HUNTING"
        creature.targetX = soundX
        creature.targetY = soundY
    
    else if creature.state == "SEARCHING":
        // New sound while searching = hunt new location
        creature.state = "HUNTING"
        creature.targetX = soundX
        creature.targetY = soundY

function updateCreature(creature, deltaTime):
    switch creature.state:
        
        case "PATROL":
            if creature.patrolPath.length == 0:
                // Stationary, just sway
                updateCreatureIdle(creature, deltaTime)
            else:
                // Move toward current waypoint
                waypoint = creature.patrolPath[creature.patrolIndex]
                moveToward(creature, waypoint.x, waypoint.y, CREATURE.patrolSpeed, deltaTime)
                
                // Check if reached waypoint
                if dist(creature.x, creature.y, waypoint.x, waypoint.y) < 10:
                    creature.patrolIndex = (creature.patrolIndex + 1) % creature.patrolPath.length
        
        case "ALERT":
            // Stand still, facing sound
            creature.stateTimer -= deltaTime
            updateCreatureIdle(creature, deltaTime)
            
            if creature.stateTimer <= 0:
                creature.state = "RETURNING"
        
        case "HUNTING":
            moveToward(creature, creature.targetX, creature.targetY, CREATURE.huntSpeed, deltaTime)
            
            // Check if reached target
            if dist(creature.x, creature.y, creature.targetX, creature.targetY) < 30:
                creature.state = "SEARCHING"
                creature.stateTimer = CREATURE.searchDuration
                creature.searchAngle = 0
        
        case "SEARCHING":
            // Circle the target location
            creature.searchAngle += (CREATURE.patrolSpeed / CREATURE.searchRadius) * deltaTime
            creature.x = creature.targetX + cos(creature.searchAngle) * CREATURE.searchRadius
            creature.y = creature.targetY + sin(creature.searchAngle) * CREATURE.searchRadius
            
            creature.stateTimer -= deltaTime
            if creature.stateTimer <= 0:
                creature.state = "RETURNING"
        
        case "RETURNING":
            if creature.patrolPath.length == 0:
                // Return to start position
                returnTarget = {x: creature.startX, y: creature.startY}
            else:
                // Return to nearest patrol waypoint
                returnTarget = findNearestWaypoint(creature)
            
            moveToward(creature, returnTarget.x, returnTarget.y, CREATURE.returnSpeed, deltaTime)
            
            if dist(creature.x, creature.y, returnTarget.x, returnTarget.y) < 10:
                creature.state = "PATROL"
    
    // Update sprite position
    creature.sprite.x = creature.x
    creature.sprite.y = creature.y

function moveToward(creature, targetX, targetY, speed, deltaTime):
    dx = targetX - creature.x
    dy = targetY - creature.y
    distance = sqrt(dx * dx + dy * dy)
    
    if distance > 0:
        creature.x += (dx / distance) * speed * deltaTime
        creature.y += (dy / distance) * speed * deltaTime
        creature.facingAngle = atan2(dy, dx)

// ============================================================================
// PLAYER
// ============================================================================

function createPlayer(x, y):
    player = {
        sprite: createPlayerSprite(x, y),
        x: x,
        y: y,
        velocityX: 0,
        velocityY: 0,
        lightRadius: PLAYER.lightRadius
    }
    return player

function handlePlayerInput():
    player.velocityX = 0
    player.velocityY = 0
    
    if keyIsDown('LEFT') or keyIsDown('A'):
        player.velocityX = -PLAYER.speed
    if keyIsDown('RIGHT') or keyIsDown('D'):
        player.velocityX = PLAYER.speed
    if keyIsDown('UP') or keyIsDown('W'):
        player.velocityY = -PLAYER.speed
    if keyIsDown('DOWN') or keyIsDown('S'):
        player.velocityY = PLAYER.speed
    
    // Normalize diagonal movement
    if player.velocityX != 0 and player.velocityY != 0:
        factor = 1 / sqrt(2)
        player.velocityX *= factor
        player.velocityY *= factor

function updatePlayerPosition(deltaTime):
    newX = player.x + player.velocityX * deltaTime
    newY = player.y + player.velocityY * deltaTime
    
    // Wall collision (simplified AABB)
    playerRect = {
        x: newX - PLAYER.width/2,
        y: newY - PLAYER.height/2,
        width: PLAYER.width,
        height: PLAYER.height
    }
    
    canMoveX = true
    canMoveY = true
    
    for each wall in walls:
        if rectOverlap({x: newX - PLAYER.width/2, y: player.y - PLAYER.height/2, width: PLAYER.width, height: PLAYER.height}, wall):
            canMoveX = false
        if rectOverlap({x: player.x - PLAYER.width/2, y: newY - PLAYER.height/2, width: PLAYER.width, height: PLAYER.height}, wall):
            canMoveY = false
    
    for each obstacle in obstacles:
        if rectOverlap({x: newX - PLAYER.width/2, y: player.y - PLAYER.height/2, width: PLAYER.width, height: PLAYER.height}, obstacle):
            canMoveX = false
        if rectOverlap({x: player.x - PLAYER.width/2, y: newY - PLAYER.height/2, width: PLAYER.width, height: PLAYER.height}, obstacle):
            canMoveY = false
    
    if canMoveX:
        player.x = newX
    if canMoveY:
        player.y = newY
    
    player.sprite.x = player.x
    player.sprite.y = player.y

// ============================================================================
// AUDIO
// ============================================================================

function updateProximityAudio():
    // Find nearest creature
    minDist = Infinity
    for each creature in creatures:
        d = dist(player.x, player.y, creature.x, creature.y)
        if d < minDist:
            minDist = d
    
    // Heartbeat when creature within 150 pixels
    if minDist < 150:
        intensity = 1 - (minDist / 150)
        heartbeatRate = 60 + intensity * 90  // 60-150 BPM
        heartbeatVolume = 0.2 + intensity * 0.3
        playHeartbeat(heartbeatRate, heartbeatVolume)
    else:
        stopHeartbeat()

// ============================================================================
// LEVEL FLOW
// ============================================================================

function playerDeath():
    playSound('death', volume: 0.6)
    flashScreen(0xff0000, 100)
    restartLevel()

function restartLevel():
    loadLevel(currentLevel)

function completeLevel():
    playSound('complete', volume: 0.3)
    currentLevel++
    
    if currentLevel > 9:
        displayEnding()
    else:
        fadeOut(300, function():
            loadLevel(currentLevel)
            fadeIn(300)
        )

function displayEnding():
    gameState = "ending"
    clearLevel()
    
    // Brighten background gradually
    tweenBackgroundColor(0x0a0a0a, 0x1a1a2a, 2000)
    
    // Show player silhouette
    createPlayerSprite(512, 400)
    
    // Text sequence
    after(2000, function():
        text1 = createText(512, 550, "Some fears are louder than others.", {
            fontFamily: "Georgia, serif",
            fontSize: 28,
            color: "#ffffff",
            alpha: 0
        })
        text1.setOrigin(0.5)
        fadeInText(text1, 1000)
    )
    
    after(5000, function():
        text2 = createText(512, 600, "You learned to quiet yours.", {
            fontFamily: "Georgia, serif",
            fontSize: 24,
            color: "#aaaaaa",
            alpha: 0
        })
        text2.setOrigin(0.5)
        fadeInText(text2, 1000)
    )
    
    after(7000, function():
        this.input.once('pointerdown', displayTitleScreen)
    )

// ============================================================================
// RENDERING HELPERS
// ============================================================================

function createDarknessOverlay():
    // Create black rectangle covering screen
    darknessOverlay = createRectangle(0, 0, 1024, 768, 0x0a0a0a)
    darknessOverlay.alpha = 0.95
    darknessOverlay.setDepth(100)  // Above everything
    
    // Create light mask with holes for:
    // - Player position (150px radius)
    // - Cursor position (30px radius)
    // - Exit position (100px radius)
    // Implementation depends on Phaser version (masks or blend modes)

function updateDarknessOverlay():
    // Update light hole positions
    playerLightMask.x = player.x
    playerLightMask.y = player.y
    
    cursorLightMask.x = cursorPosition.x
    cursorLightMask.y = cursorPosition.y

function initializeCursorGlow():
    cursorGlow = createCircle(cursorPosition.x, cursorPosition.y, CURSOR.glowRadius, 0x8888cc, 0.3)
    cursorGlow.setDepth(200)  // Above everything including darkness

function updateCursorGlow():
    cursorGlow.x = cursorPosition.x
    cursorGlow.y = cursorPosition.y
    
    // Breathing animation
    cursorGlow.alpha = 0.25 + 0.1 * sin(getCurrentTime() * 0.003)

function drawWaveRing(x, y, radius, alpha):
    waveGraphics.lineStyle(WAVE.strokeWidth, 0x6666aa, alpha)
    waveGraphics.strokeCircle(x, y, radius)

// ============================================================================
// END PSEUDOCODE
// ============================================================================
