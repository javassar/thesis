## 1. Title & Hook
**Clockwork Filing Wheel**

Forms fall down a central chute. You don’t drag them—your only power is rotating a four-department carousel and stamping at the exact moment the form hits the intake slot. Misfiles don’t just penalize you; they jam the machine and warp the labels, turning bureaucracy into a physical, clocklike combat puzzle.

---

## 2. Core Insight.
**Central question / truth this game explores:**  
When you can’t control the workload, you control the system’s *alignment*—small timing and positioning decisions determine whether the machine helps you or crushes you.

**Why this matters to a human player:**  
It captures the feeling of being a small operator inside a larger process: you’re not “doing magic,” you’re keeping the mechanism from desynchronizing. The stress is readable, fair, and satisfying because success comes from rhythm and control rather than menu knowledge.

---

## 3. Mechanic-theme integration.
**Primary mechanic (what the player does):**
1) Rotate a 4-slot carousel left/right.  
2) Press **SPACE** to stamp a falling form when it is inside the intake window.  
3) Survive mechanical “malfunctions” that temporarily distort information (labels) or controls (torque), forcing reliance on fundamentals (color/type recognition + timing).

**How this mechanic embodies the theme (not just accompanies it):**  
Bureaucracy becomes literal machinery: departments are rotating sectors, and correct filing is mechanical alignment + timing. Mistakes physically destabilize the system (chaos increases, jams occur, labels slip), mirroring how procedural errors create downstream chaos.

---

## 5. Technical specification.
### Display specs
- **Framework:** Phaser 3
- **Canvas size:** 960 × 540
- **Scale:** `Phaser.Scale.FIT`, centered (`CENTER_BOTH`)
- **Camera background color:** `#151826` (deep navy)

### Layout (exact positions)
**A) Central chute**
- Chute rectangle: x=430, y=0, w=100, h=320, fill `#202641`
- Chute side borders: 2px lines at x=430 and x=530, color `#3a456d`
- Intake window (stamping zone):
  - Center line y = 250
  - Window range: `INTAKE_Y_MIN = 232`, `INTAKE_Y_MAX = 268`
  - Draw two horizontal lines at y=232 and y=268, thickness 3, color `#ffcc66`
  - Label “INTAKE” at x=20, y=228, font 16, color `#ffcc66`

**B) Filing wheel (carousel)**
- Wheel center: `(WHEEL_X, WHEEL_Y) = (480, 390)`
- Wheel outer radius: `R_OUT = 150`
- Wheel inner radius: `R_IN = 92` (donut)
- Four department sectors (each 90 degrees), drawn as colored wedges (Graphics arcs) with a thin divider:
  - Divider lines at 0°, 90°, 180°, 270° from center, thickness 2, color `#0f1220`
- **Gate direction (the sector currently “under” the intake):**
  - Gate is at the very top of wheel (world angle -90° / 270°).
  - The sector whose center angle is closest to -90° is the active department at intake.

**C) Department identities (color + short code)**
There are 4 spell form types and 4 departments; color is the truth (labels can lie during incidents).
- FIRE (Furnace): color `#ff5c7a`, doc code prefix `F`
- WATER (Aquatics): color `#4dabff`, doc code prefix `W`
- ILLUSION (PR): color `#b388ff`, doc code prefix `I`
- NECRO (Archives): color `#66ff99`, doc code prefix `N`

**D) Sector label positions (fixed to wheel rotation)**
Each sector has a label drawn at radius 122, at the sector’s center angle relative to wheel rotation.
- Font: `Courier New`, size 16, color `#0f1220` on a light backing
- Backing: small rounded rect behind text, fill `rgba(255,255,255,0.75)`, size 92×22

**E) UI (top bar)**
Top bar: x=0, y=0, w=960, h=44, fill `#1e2340`
- Timer text: x=20, y=12 — `Courier New`, 20px, color `#d7e0ff`
- Filed: x=260, y=14 — 16px, color `#d7e0ff`
- Misfile: x=380, y=14 — 16px, color `#d7e0ff`
- Missed: x=520, y=14 — 16px, color `#d7e0ff`
- Chaos label: x=660, y=14 — 16px, color `#d7e0ff`
- Chaos bar:
  - Background rect: x=720, y=16, w=220, h=14, fill `#0f1220`
  - Fill rect: x=720, y=16, w=0..220, h=14
  - Fill color by chaos:
    - chaos < 40: `#66ff99`
    - 40–69: `#ffcc66`
    - >= 70: `#ff5c7a`

**F) Feedback text (center-left)**
- Small event log line at x=20, y=60, font 16, color `#d7e0ff`
- Shows last action: “FILED ✓”, “MISFILE ✗”, “MISSED!”, “JAM CLEARED”, etc.
- Fades after 1.2s (alpha tween to 0)

---

### Inputs (exact)
- Rotate wheel:
  - `LEFT ARROW`: rotate counterclockwise
  - `RIGHT ARROW`: rotate clockwise
  - Rotation speed: `WHEEL_ANGULAR_SPEED = 2.6 rad/sec` (≈149°/sec)
- Stamp:
  - `SPACE`: attempt to file the **lowest (closest to intake)** form currently in the chute *if* it is within intake window (`INTAKE_Y_MIN..INTAKE_Y_MAX`)
- Pause:
  - `ESC`: toggle pause
- Restart:
  - `R`: restart only on end screen

No mouse required (keeps it laptop-friendly and arcade-clean).

---

### Game state information
#### Duration and ending
- `SHIFT_DURATION_MS = 300000` (5 minutes)
- Game ends distinctly on win/lose screen.

#### Spawning and motion
- Forms fall straight down the chute at fixed x = 480.
- Spawn interval decreases over time:
  - `spawnIntervalMsStart = 900`
  - Every 60 seconds: `spawnIntervalMs -= 80`
  - Clamp: `spawnIntervalMsMin = 520`
- Fall speed increases over time:
  - `fallSpeedStart = 130 px/sec`
  - Every 60 seconds: `fallSpeed += 18 px/sec`
  - Clamp: `fallSpeedMax = 220 px/sec`

#### Form properties
- Form size: 70×44
- Form spawn position: x=480, y=70
- Each form has:
  - `type` in `{FIRE, WATER, ILLUSION, NECRO}`
  - `color` as above
  - `idNumber` integer 1..99 (random) displayed like “F-07”
- Form rendering:
  - Rounded rect (radius 8) in its type color
  - Border 2px in `#0f1220`
  - Text centered, `Courier New` 18 bold, color `#0f1220`

#### Filing rules
At any moment, one department sector is “active” at the intake (top of wheel).
- Determine active department by wheel angle:
  - Let `wheelRotation` be radians, increasing clockwise (Phaser rotation convention can be used; define consistently).
  - Define sector center angles in wheel local space:
    - Sector 0 center: 0 rad
    - Sector 1: π/2
    - Sector 2: π
    - Sector 3: 3π/2
  - Convert each to world angle: `worldAngle = normalizeAngle(sectorCenter + wheelRotation)`
  - Gate angle is `GATE_ANGLE = -π/2` (top)
  - Active sector index is the one minimizing `angleDistance(worldAngle, GATE_ANGLE)`
- When SPACE is pressed:
  - Choose target form = the form with maximum y that is still `< WHEEL_Y - R_OUT`? (i.e., still above wheel)
  - Actually for simplicity and determinism: choose the form with greatest y among all forms.
  - If target form exists AND `INTAKE_Y_MIN <= target.y <= INTAKE_Y_MAX`:
    - If target.type == activeDepartment.type → filed
    - else → misfile
    - Destroy the form on any stamp attempt within window (correct or incorrect).
  - If SPACE is pressed with no form in window → do nothing (no penalty).

#### Missed rules
- A form is **missed** if `form.y > (WHEEL_Y + R_OUT)` (falls past the wheel)
  - When missed: destroy form, `missedCount += 1`, `chaos += 7`

#### Variables (initial values)
- `timeStartMs = this.time.now`
- `timeLeftMs = SHIFT_DURATION_MS`
- `filedCount = 0`
- `misfileCount = 0`
- `missedCount = 0`
- `chaos = 0` (clamp 0..100)
- `paused = false`
- `gameEnded = false`
- `didWin = false`
- `wheelRotation = 0` (radians)
- `spawnIntervalMs = spawnIntervalMsStart`
- `fallSpeed = fallSpeedStart`
- `forms = []` (array of active form objects / containers)
- `malfunction = null` (object or null)
- `nextMinuteMarkMs = 60000`
- `minuteCount = 0`

#### Chaos changes
- Correct file:
  - `filedCount += 1`
  - `chaos = max(0, chaos - 2)`
- Misfile:
  - `misfileCount += 1`
  - `chaos += 9`
  - 50% chance to trigger a malfunction if none active
- Missed:
  - `missedCount += 1`
  - `chaos += 7`

Clamp always: `chaos = clamp(chaos, 0, 100)`

#### Malfunctions (system-level twists)
Malfunctions do **not** stop time; they distort control/information for short bursts.
- Trigger:
  - On misfile: `if malfunction == null && Math.random() < 0.50 => triggerMalfunction()`
  - Also guaranteed at minute marks 2 and 4 (120s, 240s): if no malfunction, trigger one.
- Types (weighted):
  1) **LABEL SLIP** (weight 3, duration 10s)
     - The **text labels** rotate 90° ahead (i.e., displayed department names are shifted), but sector colors remain correct.
     - Effect: Only visuals change; logic mapping remains tied to sector color/type.
     - On start: `chaos += 4`
     - On end: `chaos -= 2`
  2) **TORQUE REVERSAL** (weight 2, duration 6s)
     - Left/Right controls swap (left rotates clockwise, right rotates counterclockwise).
     - On start: `chaos += 5`
     - On end: no chaos change
  3) **GEAR DRAG** (weight 1, duration 8s)
     - Wheel angular speed reduced by 35%: `effectiveAngularSpeed = base * 0.65`
     - On start: `chaos += 3`
     - On end: no chaos change

During a malfunction, show a banner under top bar:
- Banner rect: x=0, y=44, w=960, h=26, fill `#2a2f44`
- Banner text: x=20, y=50, font 16, color `#ffcc66` (e.g., “MALFUNCTION: TORQUE REVERSAL (6s)”)

#### Win/lose conditions (boolean expressions)
Checked every update:
- **Lose:** `(chaos >= 100) || (missedCount >= 10)`
- **Win:** `(timeLeftMs <= 0) && (chaos < 100)`

#### Win grade (for ending flavor; still a single win state)
- A: `filedCount >= 78`
- B: `60 <= filedCount <= 77`
- C: `45 <= filedCount <= 59`
- D: `< 45`

---

### Assets
All generated via Phaser Graphics + Text (no external files).
Optional sound (purely optional; safe to omit):
- Correct file: short sine beep (880Hz, 0.05s)
- Misfile: buzz (sawtooth 140Hz, 0.08s)
- Missed: low thud (square 90Hz, 0.08s)

---

## 6. Implementation pseudo code.
```pseudo
CLASS GameScene EXTENDS Phaser.Scene

CREATE():
  setBackgroundColor(#151826)

  // --- constants ---
  SHIFT_DURATION_MS = 300000

  spawnIntervalMsStart = 900
  spawnIntervalMsMin = 520
  spawnIntervalDecayPerMinute = 80

  fallSpeedStart = 130
  fallSpeedPerMinute = 18
  fallSpeedMax = 220

  WHEEL_X=480; WHEEL_Y=390
  R_OUT=150; R_IN=92

  INTAKE_Y_MIN=232; INTAKE_Y_MAX=268
  GATE_ANGLE = -PI/2

  baseAngularSpeed = 2.6

  // --- state ---
  timeStartMs = this.time.now
  timeLeftMs = SHIFT_DURATION_MS
  filedCount=0; misfileCount=0; missedCount=0
  chaos=0
  paused=false
  gameEnded=false; didWin=false

  wheelRotation=0
  spawnIntervalMs = spawnIntervalMsStart
  fallSpeed = fallSpeedStart

  forms = []         // array of {container, type, y, id}
  malfunction = null // {type, timeLeftMs, ...}

  minuteCount=0
  nextMinuteMarkMs = 60000

  // --- input ---
  keyLeft = addKey(LEFT)
  keyRight = addKey(RIGHT)
  keySpace = addKey(SPACE)
  keyEsc = addKey(ESC)
  keyR = addKey(R)

  on ESC down: if !gameEnded => paused = !paused; show/hide paused overlay

  // --- draw UI ---
  drawTopBar()
  createTexts(timerText, filedText, misfileText, missedText)
  createChaosBar()

  eventLogText = addText(20,60,"", Courier 16 #d7e0ff).setAlpha(0)

  // malfunction banner
  malfunctionBannerRect + malfunctionBannerText initially hidden

  // --- draw chute ---
  drawChuteRect(430,44,100,276) // below top bar & banner area
  drawIntakeLines(y=232 and 268)
  addText(20,228,"INTAKE", Courier 16 #ffcc66)

  // --- wheel graphics containers ---
  wheelGfx = this.add.graphics()
  wheelLabelsContainer = this.add.container(0,0)
  // store sector definitions
  sectors = [
    {type:"FIRE", color:#ff5c7a, name:"FURNACE", codePrefix:"F"},
    {type:"WATER", color:#4dabff, name:"AQUATICS", codePrefix:"W"},
    {type:"ILLUSION", color:#b388ff, name:"PR / ILLUSION", codePrefix:"I"},
    {type:"NECRO", color:#66ff99, name:"ARCHIVES", codePrefix:"N"}
  ]

  // --- spawn timer ---
  spawnEvent = time.addEvent({
    delay: spawnIntervalMs,
    loop: true,
    callback: () => { if canSpawn() => spawnForm() }
  })

  // initial draw
  redrawWheel()

  updateUI()

FUNCTION canSpawn():
  return (!paused && !gameEnded)

FUNCTION spawnForm():
  // choose random type index 0..3
  idx = randomInt(0,3)
  sector = sectors[idx]
  idNum = randomInt(1,99)
  code = sector.codePrefix + "-" + pad2(idNum)

  // create container at x=480, y=70
  c = add.container(480,70)
  bg = graphicsRoundedRect(-35,-22,70,44,r=8, fill=sector.color, stroke=2 #0f1220)
  label = addText(0,0,code, Courier 18 bold #0f1220).setOrigin(0.5)
  c.add(bg,label)

  forms.push({container:c, type:sector.type})

FUNCTION getEffectiveAngularSpeed():
  speed = baseAngularSpeed
  if malfunction != null and malfunction.type == "GEAR_DRAG":
    speed = speed * 0.65
  return speed

FUNCTION isTorqueReversed():
  return malfunction != null and malfunction.type == "TORQUE_REVERSAL"

FUNCTION handleStamp():
  // find lowest form (max y)
  if forms.length == 0: return
  target = form with max container.y
  y = target.container.y
  if y < INTAKE_Y_MIN or y > INTAKE_Y_MAX: return

  activeIndex = computeActiveSectorIndexAtGate()
  activeType = sectors[activeIndex].type

  // destroy stamped form regardless
  destroy target.container
  remove target from forms

  if target.type == activeType:
    filedCount += 1
    chaos = max(0, chaos - 2)
    logEvent("FILED ✓", color=#66ff99)
  else:
    misfileCount += 1
    chaos += 9
    logEvent("MISFILE ✗", color=#ff5c7a)
    if malfunction == null and randomFloat() < 0.50:
      triggerMalfunction()

  chaos = clamp(chaos,0,100)
  updateUI()

FUNCTION computeActiveSectorIndexAtGate():
  // sectors local center angles: 0, PI/2, PI, 3PI/2
  bestIndex = 0
  bestDist = +INF
  for i in 0..3:
    localCenter = i * (PI/2)
    worldAngle = normalizeAngle(localCenter + wheelRotation)
    dist = angleDistance(worldAngle, GATE_ANGLE) // returns 0..PI
    if dist < bestDist: bestDist=dist; bestIndex=i
  return bestIndex

FUNCTION redrawWheel():
  wheelGfx.clear()

  // draw donut base (optional darker ring behind wedges)
  drawRingBackground()

  // draw 4 wedges (each 90 degrees) with rotation wheelRotation
  for i in 0..3:
    startAngle = wheelRotation + i*(PI/2) - (PI/4)
    endAngle   = wheelRotation + i*(PI/2) + (PI/4)
    color = sectors[i].color
    wheelGfx.fillStyle(color, 1)
    wheelGfx.slice(WHEEL_X, WHEEL_Y, R_OUT, startAngle, endAngle, false)
    wheelGfx.fillPath()
    // cut inner circle by drawing inner slice in background color (simple technique)
    wheelGfx.fillStyle(#151826, 1)
    wheelGfx.slice(WHEEL_X, WHEEL_Y, R_IN, startAngle, endAngle, false)
    wheelGfx.fillPath()

  // draw divider lines
  for k in 0..3:
    ang = wheelRotation + k*(PI/2)
    x1 = WHEEL_X + R_IN*cos(ang)
    y1 = WHEEL_Y + R_IN*sin(ang)
    x2 = WHEEL_X + R_OUT*cos(ang)
    y2 = WHEEL_Y + R_OUT*sin(ang)
    wheelGfx.lineStyle(2, #0f1220, 1)
    wheelGfx.beginPath(); moveTo(x1,y1); lineTo(x2,y2); strokePath()

  // draw gate indicator triangle at top of wheel
  drawSmallTriangleAt(WHEEL_X, WHEEL_Y - R_OUT - 10, color=#ffcc66)

  // labels: rebuild each frame (simple) OR update existing label positions
  wheelLabelsContainer.removeAll(true)
  for i in 0..3:
    // displayed name may be shifted during LABEL_SLIP
    nameIndex = i
    if malfunction != null and malfunction.type == "LABEL_SLIP":
      nameIndex = (i + 1) mod 4  // labels lie by shifting 90° ahead

    name = sectors[nameIndex].name

    labelAngle = wheelRotation + i*(PI/2)
    lx = WHEEL_X + 122*cos(labelAngle)
    ly = WHEEL_Y + 122*sin(labelAngle)

    backing = graphicsRoundedRect(lx-46, ly-11, 92, 22, r=6, fill=rgba(255,255,255,0.75))
    txt = addText(lx, ly, name, Courier 16 #0f1220).setOrigin(0.5)
    wheelLabelsContainer.add(backing)
    wheelLabelsContainer.add(txt)

FUNCTION triggerMalfunction():
  // weighted random
  pick = weightedRandom([("LABEL_SLIP",3),("TORQUE_REVERSAL",2),("GEAR_DRAG",1)])

  if pick == "LABEL_SLIP":
    malfunction = {type:"LABEL_SLIP", timeLeftMs:10000}
    chaos += 4
    showMalfunctionBanner("MALFUNCTION: LABEL SLIP (10s)")
  if pick == "TORQUE_REVERSAL":
    malfunction = {type:"TORQUE_REVERSAL", timeLeftMs:6000}
    chaos += 5
    showMalfunctionBanner("MALFUNCTION: TORQUE REVERSAL (6s)")
  if pick == "GEAR_DRAG":
    malfunction = {type:"GEAR_DRAG", timeLeftMs:8000}
    chaos += 3
    showMalfunctionBanner("MALFUNCTION: GEAR DRAG (8s)")

  chaos = clamp(chaos,0,100)
  updateUI()

FUNCTION updateMalfunction(deltaMs):
  if malfunction == null: return
  malfunction.timeLeftMs -= deltaMs
  updateBannerCountdown(malfunction.timeLeftMs)
  if malfunction.timeLeftMs <= 0:
    // end effects
    if malfunction.type == "LABEL_SLIP":
      chaos = max(0, chaos - 2)
    malfunction = null
    hideMalfunctionBanner()
    chaos = clamp(chaos,0,100)
    updateUI()

FUNCTION updateDifficulty(elapsedMs):
  if elapsedMs >= nextMinuteMarkMs:
    minuteCount += 1
    nextMinuteMarkMs += 60000

    spawnIntervalMs = max(spawnIntervalMsMin, spawnIntervalMs - spawnIntervalDecayPerMinute)
    spawnEvent.reset({delay:spawnIntervalMs, loop:true, callback: () => { if canSpawn() spawnForm() }})

    fallSpeed = min(fallSpeedMax, fallSpeedStart + minuteCount*fallSpeedPerMinute)

    // guaranteed malfunctions at 2 and 4 minutes
    if (minuteCount == 2 or minuteCount == 4) and malfunction == null:
      triggerMalfunction()

FUNCTION updateForms(deltaMs):
  // move all forms downward
  for each f in forms:
    f.container.y += fallSpeed * (deltaMs/1000)

  // missed check: past wheel bottom
  missY = WHEEL_Y + R_OUT
  for each f in forms where f.container.y > missY:
    destroy f.container
    remove f from forms
    missedCount += 1
    chaos += 7
    chaos = clamp(chaos,0,100)
    logEvent("MISSED!", color=#ffcc66)

FUNCTION rotateWheel(deltaMs):
  speed = getEffectiveAngularSpeed()
  dir = 0
  if keyLeft is down: dir -= 1
  if keyRight is down: dir += 1
  if dir == 0: return

  // torque reversal swaps meaning
  if isTorqueReversed():
    dir = -dir

  wheelRotation += dir * speed * (deltaMs/1000)
  wheelRotation = normalizeAngle(wheelRotation)

FUNCTION updateUI():
  timerText = "SHIFT: " + formatTime(timeLeftMs)
  filedText = "FILED: " + filedCount
  misfileText = "MISFILE: " + misfileCount
  missedText = "MISSED: " + missedCount
  chaosBarFillWidth = round(220 * (chaos/100))
  setChaosBarFillWidth(chaosBarFillWidth)
  setChaosBarFillColorByThreshold()

FUNCTION checkEndConditions():
  lose = (chaos >= 100) OR (missedCount >= 10)
  win = (timeLeftMs <= 0) AND (chaos < 100)

  if lose: endGame(false)
  else if win: endGame(true)

FUNCTION endGame(winFlag):
  gameEnded = true
  didWin = winFlag
  spawnEvent.remove(false)

  // destroy remaining forms
  for each f in forms: destroy f.container
  forms.clear()

  // hide malfunction banner
  malfunction = null
  hideMalfunctionBanner()

  // show end overlay
  showDimOverlay()
  if winFlag:
    grade = computeGrade(filedCount)
    title="SHIFT COMPLETE"
    subtitle="GRADE: " + grade
  else:
    title="MECHANISM FAILURE"
    subtitle="THE WHEEL DESYNCHRONIZED"

  showStats(FILED, MISFILE, MISSED, CHAOS)
  showPrompt("Press R to Restart")

UPDATE(time, deltaMs):
  if gameEnded:
    if keyR justDown: scene.restart()
    return

  if keyEsc justDown: togglePause()

  if paused: return

  elapsedMs = time - timeStartMs
  timeLeftMs = max(0, SHIFT_DURATION_MS - elapsedMs)

  updateDifficulty(elapsedMs)

  updateMalfunction(deltaMs)

  rotateWheel(deltaMs)

  if keySpace justDown:
    handleStamp()

  updateForms(deltaMs)

  redrawWheel()    // simple approach: redraw each frame (fine for this scope)

  updateUI()

  checkEndConditions()

// --- helpers ---
FUNCTION normalizeAngle(a):
  while a <= -PI: a += 2*PI
  while a > PI: a -= 2*PI
  return a

FUNCTION angleDistance(a,b):
  d = abs(normalizeAngle(a-b))
  return d

FUNCTION formatTime(ms):
  total = ceil(ms/1000)
  m = floor(total/60)
  s = total % 60
  return m + ":" + (s<10?"0":"") + s
```