## 1. Title & Hook

**Title:** **Resonance Ledger**  
**Hook:** You don’t reveal the cave—you **compose it**. Each click places a “note” of sound that briefly draws the world in echo-lines. But the creature hunts **patterns**, not volume: repeating rhythms make you predictable. Escape by navigating between fleeting maps while **writing misleading sound trails** the monster can’t resist.

---

## 2. Core Insight

**Central question/truth:**  
When you act with incomplete information, do you cling to habits—or can you *change your pattern* fast enough to survive?

**Why this matters to a human player:**  
In real life, people become readable through routines. This game makes routine dangerous: repeating the same move/ping cadence becomes a signature the hunter learns. You must stay flexible—strategically inconsistent—while still executing a plan.

---

## 3. Mechanic-theme integration

**Primary mechanic (what the player does):**
- **Place an Echo Mark (left click)**: a short-lived “sound note” that emits a pulse revealing geometry in **thin line strokes** for 1.1 seconds.
- **Chain Marks**: you can hold up to **3 marks** at once; placing a 4th deletes the oldest.
- **Footsteps create micro-pings** automatically (very small reveals) but also feed the hunter.
- **Rhythm memory**: if you place marks at near-identical intervals (same cadence), the hunter enters **Lock-On** mode and predicts your next position.

**How the mechanic embodies the theme:**
- The world exists in **brief, authored perceptions**—you decide what information to generate and where.
- The enemy punishes **habit** (repetitive cadence), forcing players to keep adapting their own behavior.
- Success becomes: “probe → infer → commit → deliberately break pattern → survive,” which maps to human decision-making under uncertainty.

---

## 5. Technical specification

### 5.1 Display specs
- **Framework:** Phaser 3
- **Canvas:** `960 x 540`
- **Camera:** fixed
- **Background color:** `#05060A`
- **World bounds:** `0..960`, `0..540`

#### Visual language
- Darkness baseline: almost everything at alpha 0.
- Reveals are **line-based** (strokes) and **echo trails** (thin fading segments), to sell “sound drawing space.”
- Player is always visible.

#### Fonts
- UI font: `monospace`
- Primary UI color: `#E8F1FF`
- Danger color: `#FF4D6D`
- Accent: `#FFD166`

---

### 5.2 Game elements (sizes, colors, behaviors)

#### Player
- Shape: circle
- Radius: `10`
- Fill: `#BFD7FF`, `alpha = 1.0` always
- Speed: `135 px/s`
- Special: player footsteps generate **micro-echo** (tiny reveal) and a **footstep event** for AI.

#### Echo Mark (placed by click)
- Visual: small ring (stroked circle)
- Radius: `7`
- Color: `#FFD166`
- Lifetime: `4.0 s` (exists as a “note” even after its reveal fades; AI can hear it)
- Capacity: max `3` marks simultaneously (circular queue)
- On placement: emits a **Reveal Pulse** (below) immediately.

#### Reveal Pulse (from Echo Mark)
- Pulse radius expands `0 → 280 px` over `0.22 s`
- Reveal duration: `1.1 s` linearly fading
- Reveals:
  - walls, hazards, exit, enemy
  - plus draws **echo-trail segments** along the pulse perimeter briefly (purely visual)

#### Walls (maze)
- Rectangles, static bodies
- Render: invisible fill; stroke visible only when revealed
- Stroke color: `#8AA0B8`, stroke thickness `2`
- Reveal alpha behavior: same “revealUntil” timer model

#### Hazards: “Chimes” (sound traps, not instant death)
- Shape: circles radius `12`
- Color revealed: `#6CFFB2`
- Behavior: touching a Chime does **not** kill. Instead it:
  - spikes player noise by `+35` instantly
  - creates a **loud sound event** at its position (AI bait)
  - briefly stuns the player movement for `250 ms` (adds panic)
- This turns hazards into “mistakes that create story,” not binary failure.

#### Enemy: “The Auditor”
- Shape: circle radius `13`
- Color revealed: `#FF4D6D`
- Invisible unless revealed (alpha 0 otherwise)
- Speed:
  - Wander: `95 px/s`
  - Hunt: `120 px/s`
  - Lock-On: `135 px/s` for short bursts
- Kill distance: `18 px`
- Key behavior: hunts **sound events** and also learns your **mark cadence**.

#### Exit door
- Rectangle: `38 x 38`
- Color revealed: `#FFE66D`
- Win on overlap.

---

### 5.3 UI elements (exact positions)
All UI always visible.

- **Top-left:** Timer  
  - `(16, 12)`  
  - `TIME: 05:00`  
  - `20px monospace` color `#E8F1FF`

- **Top-left under timer:** Marks remaining (capacity)  
  - `(16, 36)`  
  - `MARKS: ●●●` (filled for available slots; hollow for empty)  
  - `16px monospace` color `#FFD166`

- **Top-center:** Pattern warning (only appears when relevant)  
  - `(480, 12)` origin center  
  - `PATTERN DETECTED`  
  - `18px monospace` color `#FF4D6D` alpha pulsing while active

- **Top-right:** Noise meter  
  - Label `(700, 12)` text `NOISE`
  - Bar `(780, 18)` size `160 x 14`
  - Bg `#1A2233`
  - Fill `#FF4D6D`
  - Range `0..100`

- **Bottom-center help text:**  
  - `(480, 520)` centered  
  - `WASD move   CLICK place echo mark (reveals)   Repeating rhythms gets you hunted`  
  - `14px monospace` color `#9FB3C8`

---

### 5.4 Inputs
- Movement: `W A S D`
- Place Echo Mark: `Left mouse click`
- No other inputs.

---

### 5.5 Game state information (variables + initial values)

#### Global constants
- `GAME_DURATION_MS = 300000`

**Echo marks / reveal**
- `MARK_MAX = 3`
- `MARK_LIFETIME_MS = 4000`
- `REVEAL_DURATION_MS = 1100`
- `PULSE_MAX_RADIUS = 280`
- `PULSE_EXPAND_MS = 220`

**Movement**
- `PLAYER_SPEED = 135`

**Enemy**
- `ENEMY_SPEED_WANDER = 95`
- `ENEMY_SPEED_HUNT = 120`
- `ENEMY_SPEED_LOCKON = 135`
- `ENEMY_KILL_DIST = 18`
- `ENEMY_FORGET_MS = 2600`

**Noise (still a meter, but drives events)**
- `NOISE_MAX = 100`
- `NOISE_DECAY_PER_SEC = 10`
- `NOISE_MOVE_GAIN_PER_SEC = 18`
- `NOISE_STEP_EVENT_INTERVAL_MS = 320` (footstep event cadence while moving)
- `NOISE_STEP_EVENT_STRENGTH = 12` (how “tempting” steps are to the enemy)
- `NOISE_MARK_EVENT_STRENGTH = 22`
- `NOISE_CHIME_SPIKE = 35`

**Pattern (anti-habit system)**
- `PATTERN_WINDOW = 4` (analyze last 4 mark intervals)
- `PATTERN_TOLERANCE_MS = 90` (how similar intervals must be)
- `PATTERN_LOCKON_MS = 2200` (duration enemy predicts rather than follows last event)
- `PATTERN_PREDICT_AHEAD_PX = 85` (predict forward along player velocity)

#### Runtime variables (initial)
- `timeLeftMs = 300000`
- `gameOver = false`
- `win = false`

**Noise runtime**
- `noise = 0`
- `nextStepEventTime = 0`

**Sound event system**
- `soundEvents = []` // queue of {x,y,time,strength,type}
- `MAX_SOUND_EVENTS = 12`

**Marks runtime**
- `marks = []` // queue of up to MARK_MAX mark objects
- each mark has: `x,y,createdAt,expiresAt`
- revealables: `revealUntil` per object

**Pattern runtime**
- `markTimes = []` // timestamps of recent mark placements
- `patternDetectedUntil = 0`
- `lockOnUntil = 0`

**Enemy state**
- `enemyMode = "wander" | "hunt" | "lockon"`
- `enemyTarget = {x,y}`
- `wanderTarget = randomPoint()`

#### Win/lose conditions
- **Win:** `player.overlaps(exit) && !gameOver`
- **Lose by time:** `timeLeftMs <= 0 && !win`
- **Lose by enemy:** `distance(player, enemy) <= ENEMY_KILL_DIST`

#### End handling
On win/lose: freeze movement, show overlay.

---

### 5.6 Time mechanics (timings + expectations)
- Intended loop:
  - Place mark → 0.22s expanding pulse → 1.1s fading clarity → move on memory
  - Footsteps create subtle hints but also danger.
- Marks are not a simple cooldown; you manage **capacity and lifetime**, enabling tactics:
  - triangulate space (3 marks),
  - leave decoy marks,
  - cut off pursuit by placing sound behind you.
- Pattern pressure kicks in if you place marks in a steady rhythm (e.g., every ~900ms). You must vary tempo or spacing.

---

### 5.7 Level layout (fixed coordinates; no procedural generation)

All coordinates in pixels on 960x540.

#### Player start
- `playerStart = (80, 270)`

#### Exit
- `exitPos = (900, 270)` size `38x38`, origin center

#### Border walls (thickness 20)
- Top: `(480, 10)` size `960x20`
- Bottom: `(480, 530)` size `960x20`
- Left: `(10, 270)` size `20x540`
- Right: `(950, 270)` size `20x540`

#### Internal walls (thickness 20)
(Kept similar for implementability, but tuned for “triangulation” play—open pockets that reward multi-mark mapping.)
1. `(210, 140)` size `340 x 20`
2. `(210, 400)` size `340 x 20`
3. `(370, 270)` size `20 x 320`
4. `(540, 115)` size `20 x 230`
5. `(540, 425)` size `20 x 230`
6. `(700, 270)` size `300 x 20`
7. `(785, 165)` size `20 x 210`
8. `(785, 375)` size `20 x 210`

#### Hazards: Chimes (circles radius 12)
- C1 `(255, 270)`
- C2 `(335, 210)`
- C3 `(335, 330)`
- C4 `(620, 230)`
- C5 `(620, 310)`
- C6 `(825, 270)`

These are positioned so “straight-line sprint” tends to clip at least one and cause a loud mistake—creating emergent chase stories.

#### Enemy start
- `enemyStart = (860, 90)`

---

### 5.8 Assets descriptions
No external assets; use Phaser vector primitives:

- Player: filled circle
- Enemy: filled circle (alpha 0 unless revealed)
- Marks: stroked circle + tiny center dot
- Walls: rectangles with stroke (alpha 0 unless revealed)
- Chimes: circles (alpha 0 unless revealed)
- Exit: rectangle (alpha 0 unless revealed)
- Pulse: expanding stroked circle drawn via Graphics
- Optional: thin “echo trail” arcs on the pulse ring for style (still Graphics)

Sound optional:
- Mark placement: “ping”
- Chime trigger: bright “ting”
- Pattern detected: low warning blip

If no audio, show small textual cues near top-center.

---

### 5.9 End screens
Centered overlay:

- Full-screen translucent rect `(480,270)` size `960x540`, fill `#000000`, alpha `0.7`
- Main text:
  - Win: `BALANCED THE LEDGER`
  - Lose: `AUDITED IN THE DARK`
- Subtext: `Refresh to play again`
- Colors: `#E8F1FF`
- Font sizes: main `48px monospace`, sub `18px monospace`

---

## 6. Implementation pseudo code

```pseudo
SCENE: MainScene

PRELOAD:
  none

CREATE:
  set bg #05060A
  physics world bounds 960x540

  groups:
    wallsStatic
    chimesStatic
    revealables = []

  player:
    circle(80,270,10,#BFD7FF), physics body circle, collide world bounds

  enemy:
    circle(860,90,13,#FF4D6D), physics body circle, collide world bounds
    enemy.alpha = 0
    enemy.revealUntil = 0
    enemyMode="wander"
    wanderTarget=randomPoint()

  exit:
    rect(900,270,38,38,#FFE66D), static body
    exit.alpha=0, exit.revealUntil=0

  walls helper addWall():
    rect with invisible fill, strokeStyle(2, #8AA0B8)
    static body
    alpha=0, revealUntil=0
    add to wallsStatic and revealables

  add border walls + internal walls

  chimes helper addChime(x,y):
    circle(x,y,12,#6CFFB2), static body
    alpha=0, revealUntil=0
    add to chimesStatic and revealables

  add chimes C1..C6
  revealables.push(enemy, exit)

  collisions:
    collider(player, wallsStatic)
    collider(enemy, wallsStatic)
    overlap(player, exit, onReachExit)
    overlap(player, chimesStatic, onTouchChime)

  input:
    keys WASD
    pointerdown => placeMark(pointer.worldX, pointer.worldY)

  marks:
    marks = queue []
    markTimes = []
    patternDetectedUntil = 0
    lockOnUntil = 0

  sound event system:
    soundEvents = []
    nextStepEventTime = 0
    noise = 0

  graphics:
    pulseGfx = add.graphics()
    activePulses = [] // allow multiple pulses at once: {x,y,startTime}

  UI:
    timerText (16,12)
    marksText (16,36)
    patternText centered (480,12) initially alpha 0
    noise bar label + bg + fill
    helpText bottom center

  time:
    timeLeftMs=300000
    gameOver=false
    win=false

UPDATE(time, delta):
  if gameOver:
    player velocity 0; enemy velocity 0
    return

  // 1) timer
  timeLeftMs -= delta
  if timeLeftMs <= 0: triggerLose("time")

  // 2) player movement
  vx,vy from WASD normalized
  player.body.setVelocity(vx*PLAYER_SPEED, vy*PLAYER_SPEED)
  moving = (vx!=0 || vy!=0)

  // 3) noise meter + footstep events
  if moving:
    noise += NOISE_MOVE_GAIN_PER_SEC * (delta/1000)
    if time >= nextStepEventTime:
      pushSoundEvent(player.x, player.y, time, NOISE_STEP_EVENT_STRENGTH, "step")
      nextStepEventTime = time + NOISE_STEP_EVENT_INTERVAL_MS
  else:
    noise -= NOISE_DECAY_PER_SEC * (delta/1000)
  clamp noise 0..NOISE_MAX

  // 4) enemy decision: choose target from sound events OR lock-on prediction
  prune soundEvents older than ENEMY_FORGET_MS

  if time < lockOnUntil:
    enemyMode = "lockon"
    predicted = predictPlayerPosition(PATTERN_PREDICT_AHEAD_PX)
    enemyTarget = predicted
    enemySpeed = ENEMY_SPEED_LOCKON
  else if soundEvents not empty:
    enemyMode = "hunt"
    // pick strongest-most-recent event:
    e = selectEvent(soundEvents) by (strength * recencyWeight)
    enemyTarget = {x:e.x, y:e.y}
    enemySpeed = ENEMY_SPEED_HUNT
  else:
    enemyMode = "wander"
    enemyTarget = wanderTarget
    enemySpeed = ENEMY_SPEED_WANDER
    if distance(enemy, wanderTarget) < 10:
      wanderTarget = randomPointInsideBoundsNotInsideWalls()

  // move enemy
  dir = normalize(enemyTarget - enemy.pos)
  enemy.body.setVelocity(dir * enemySpeed)

  // 5) kill check
  if distance(player, enemy) <= ENEMY_KILL_DIST:
    triggerLose("enemy")

  // 6) draw pulses + apply reveals
  pulseGfx.clear()
  for each p in activePulses:
    t = (time - p.startTime) / PULSE_EXPAND_MS
    if t >= 1: mark p done
    else:
      r = t * PULSE_MAX_RADIUS
      pulseGfx.lineStyle(2, 0xFFD166, 0.8*(1-t))
      pulseGfx.strokeCircle(p.x, p.y, r)
  remove finished pulses

  // 7) update reveal alphas
  for obj in revealables:
    if time < obj.revealUntil:
      remaining = obj.revealUntil - time
      fade = clamp(remaining / REVEAL_DURATION_MS, 0, 1)
      obj.alpha = 0.12 + 0.88*fade
    else:
      obj.alpha = 0
  player.alpha = 1

  // 8) UI
  timerText = formatTime(timeLeftMs)
  marksText = "MARKS: " + renderDots(MARK_MAX, marks.length)
  noiseFill.width = 160 * (noise/NOISE_MAX)

  if time < patternDetectedUntil:
    patternText.alpha = 1.0
    patternText.text = "PATTERN DETECTED"
  else:
    patternText.alpha = 0

FUNCTION placeMark(mx,my):
  if gameOver: return

  // create mark GO
  mark = add.circle(mx,my,7, 0x000000, 0) // no fill
  mark.setStrokeStyle(2, 0xFFD166, 1)
  mark.createdAt = timeNow
  mark.expiresAt = timeNow + MARK_LIFETIME_MS

  // keep queue size <= MARK_MAX
  marks.push(mark)
  if marks.length > MARK_MAX:
    oldest = marks.shift()
    oldest.destroy()

  // create pulse
  activePulses.push({x:mx, y:my, startTime: timeNow})

  // reveal within radius
  for obj in revealables:
    if distance(obj, {mx,my}) <= PULSE_MAX_RADIUS:
      obj.revealUntil = max(obj.revealUntil, timeNow + REVEAL_DURATION_MS)

  // mark placement creates a sound event too (bait/decoy)
  pushSoundEvent(mx, my, timeNow, NOISE_MARK_EVENT_STRENGTH, "mark")

  // pattern detection from mark timings
  markTimes.push(timeNow)
  if markTimes.length > PATTERN_WINDOW + 1:
    markTimes.shift()

  if detectCadence(markTimes, PATTERN_TOLERANCE_MS):
    patternDetectedUntil = timeNow + 1200
    lockOnUntil = timeNow + PATTERN_LOCKON_MS

FUNCTION detectCadence(times[], tol):
  // Need at least 5 timestamps to get 4 intervals
  if times.length < PATTERN_WINDOW + 1: return false
  intervals = diffs(times)
  avg = mean(intervals)
  for each dt in intervals:
    if abs(dt - avg) > tol: return false
  return true

FUNCTION predictPlayerPosition(aheadPx):
  v = player.body.velocity
  if length(v) < 1: return {x:player.x, y:player.y}
  dir = normalize(v)
  return clampToWorld({x:player.x + dir.x*aheadPx, y:player.y + dir.y*aheadPx})

FUNCTION pushSoundEvent(x,y,t,strength,type):
  soundEvents.push({x,y,time:t,strength,type})
  if soundEvents.length > MAX_SOUND_EVENTS:
    soundEvents.shift()

FUNCTION onTouchChime(player, chime):
  // prevent retrigger spam: disable for a moment
  if chime.disabledUntil exists and timeNow < chime.disabledUntil: return
  chime.disabledUntil = timeNow + 900

  noise = min(NOISE_MAX, noise + NOISE_CHIME_SPIKE)
  pushSoundEvent(chime.x, chime.y, timeNow, 45, "chime")

  // brief stun
  playerStunUntil = timeNow + 250

UPDATE movement addition:
  if timeNow < playerStunUntil:
    player.body.setVelocity(0,0)

FUNCTION onReachExit():
  triggerWin()

FUNCTION triggerWin():
  if gameOver: return
  gameOver=true; win=true
  showOverlay("BALANCED THE LEDGER")

FUNCTION triggerLose(reason):
  if gameOver: return
  gameOver=true; win=false
  showOverlay("AUDITED IN THE DARK")

FUNCTION showOverlay(text):
  draw translucent rect full screen
  draw main text centered
  draw sub text "Refresh to play again"
```

```txt
Notes for the programmer (no extra design decisions needed):
- Keep “revealUntil” per revealable object; pulses simply extend revealUntil.
- Marks are just GameObjects + a queue; pulses are drawn via Graphics with timestamps.
- Sound events are an internal queue; enemy targets events by strength/recency.
- Pattern detection uses mark timestamps only (cheap) and triggers lock-on prediction.
- Hazards no longer insta-kill; they create loud story moments and a short stun.
- Everything remains one screen, fixed geometry, no external assets.
```