random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(7)  # ensures fresh randomness from current session
#5 gets 8 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(8)  # ensures fresh randomness from current session
#5 gets 8 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(9)  # ensures fresh randomness from current session
#5 gets 8 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(10)  # ensures fresh randomness from current session
#5 gets 8 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(11)  # ensures fresh randomness from current session
#5 gets 8 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(2026)  # ensures fresh randomness from current session
#5 gets 8 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(2022)  # ensures fresh randomness from current session
#2026 gets 9 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(424)  # ensures fresh randomness from current session
#2026 gets 9 working
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
#| label: selecting the 41 games
# set seed for reproducability
set.seed(2026)  # ensures fresh randomness from current session
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
#random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
#item_counts
just_right <- item_counts[item_counts == 7 | item_counts == 6]
just_right
# print
item_counts
#| label: Manually adjusting frequencies
# give new name so the random df isn't overwritten
semirandom_41_df <- random_41_df
semirandom_41_df[3, "Game_1"] <- "game_chat_1_echo"
View(semirandom_41_df)
?combn
?sample
items <- [1:18]
items <- 1:18
items <- c(
"game_chat_1_echo",
"game_chat_2_murmuration",
"game_chat_3_orbit",
"game_chat_4_courier",
"game_chat_5_glider",
"game_chat_6_tidepainter",
"game_claude_1_light",
"game_claude_2_moth",
"game_claude_3_bureaucromancer",
"game_claude_4_decibel",
"game_claude_5_cartographer",
"game_claude_6_flame",
"game_gemini_1_static",
"game_gemini_2_patch",
"game_gemini_3_suture",
"game_gemini_4_substratum",
"game_gemini_5_rename",
"game_gemini_6_redact"
)
# make a function to generate the blocks
generate_blocks <- function(items) {
repeat {
# step 1: assign total target frequencies (6-7 times)
target_counts <- rep(7, length(items))
target_counts[sample(1:length(items), 3)] <- 6
names(target_counts) <- items
# step 2: create item pool
pool <- rep(items, target_counts)
# step 3: shuffle the pool
pool <- sample(pool)
# step 4: form 41 blocks
blocks <- matrix(pool, ncol = 3, byrow = TRUE)
# step 5: check uniqueness of blocks
if (nrow(unique(blocks)) != 41) next
# step 6: check position balance (no game appears in a single position (e.g., "Game_1") more than 3 times)
pos_counts <- lapply(1:3, function(pos) table(blocks[, pos]))
ok_position <- TRUE
for (i in seq_along(items)) {
counts <- sapply(pos_counts, function(x) ifelse(items[i] %in% names(x), x[items[i]], 0))
if (max(counts) - min(counts) > 2) {
ok_position <- FALSE
break
}
}
if (!ok_position) next
return(as.data.frame(blocks))
}
}
# run the function to make the blocks
blocks_df <- generate_blocks(items)
# run the function to make the blocks
blocks_df <- generate_blocks(items)
colnames(blocks_df) <- c("Game_1", "Game_2", "Game_3")
22/24
#view the blocks as a df
blocks_df
View(blocks_df)
all_items_from_blocks <- unlist(blocks_df)
# count frequencies
item_counts_from_blocks <- table(all_items_from_blocks)
# print
item_counts_from_blocks
blocks_df
#| label: export the blocks as csv so i can give to claude
write.csv(blocks_df, "game_blocks.csv")
View(blocks_df)
View(blocks_df)
#| label:
any(apply(blocks_df, 1, function(row) length(unique(row)) < 3))
# make a function to generate the blocks. i had chatgpt help me generate this code
set.seed(2026)
# check 3: positional balance constraint
pos_counts <- lapply(1:3, function(pos) table(blocks[, pos]))
#| label: generate evenly distributed blocks
# set seed
set.seed(2026)
#name items again for sanity
items <- c(
"game_chat_1_echo",
"game_chat_2_murmuration",
"game_chat_3_orbit",
"game_chat_4_courier",
"game_chat_5_glider",
"game_chat_6_tidepainter",
"game_claude_1_light",
"game_claude_2_moth",
"game_claude_3_bureaucromancer",
"game_claude_4_decibel",
"game_claude_5_cartographer",
"game_claude_6_flame",
"game_gemini_1_static",
"game_gemini_2_patch",
"game_gemini_3_suture",
"game_gemini_4_substratum",
"game_gemini_5_rename",
"game_gemini_6_redact"
)
# make a function to generate the blocks. i had chatgpt help me generate this code
set.seed(2026)
generate_blocks <- function(items) {
repeat {
# step 1: assign total target frequencies (15 items get 7, 3 get 6)
target_counts <- rep(7, length(items))
target_counts[sample(seq_along(items), 3)] <- 6
names(target_counts) <- items
# step 2: create pool
pool <- rep(items, target_counts)
# step 3: shuffle
pool <- sample(pool)
# step 4: form 41 blocks
blocks <- matrix(pool, ncol = 3, byrow = TRUE)
# check 1: no duplicate items within any block
if (any(apply(blocks, 1, function(row) length(unique(row)) < 3))) next
# check 2: all blocks unique
if (nrow(unique(blocks)) != 41) next
# check 3: positional balance constraint
pos_counts <- lapply(1:3, function(pos) table(blocks[, pos]))
ok_position <- TRUE
for (item in items) {
counts <- sapply(pos_counts, function(x) ifelse(item %in% names(x), x[item], 0))
if (max(counts) - min(counts) > 2) {
ok_position <- FALSE
break
}
}
if (!ok_position) next
return(as.data.frame(blocks))
}
}
blocks_df <- generate_blocks(items)
colnames(blocks_df) <- c("Game_1", "Game_2", "Game_3")
blocks_df
#| label: storing game names
# store the names of the games
items <- c(
"game_chat_1_echo",
"game_chat_2_murmuration",
"game_chat_3_orbit",
"game_chat_4_courier",
"game_chat_5_glider",
"game_chat_6_tidepainter",
"game_claude_1_light",
"game_claude_2_moth",
"game_claude_3_bureaucromancer",
"game_claude_4_decibel",
"game_claude_5_cartographer",
"game_claude_6_flame",
"game_gemini_1_static",
"game_gemini_2_patch",
"game_gemini_3_suture",
"game_gemini_4_substratum",
"game_gemini_5_rename",
"game_gemini_6_redact"
)
#| label: selecting the 41 games randomly per pre-reg
# set seed for reproducibility
set.seed(2026)
# generate all 18 choose 3 combinations
all_combos <- combn(items, 3)
# randomly select 41 unique combinations
random_41 <- t(all_combos[, sample(ncol(all_combos), 41)])
# turn into df
random_41_df <- as.data.frame(random_41)
colnames(random_41_df) <- c("Game_1", "Game_2", "Game_3")
random_41_df
#| label: checking frequency of each game
# turn entire df into one long vector so i can count frequencies
all_items <- unlist(random_41_df)
# count frequencies
item_counts <- table(all_items)
# print
item_counts
#| label: generate evenly distributed blocks
# set seed
set.seed(2026)
#name items again for sanity
items <- c(
"game_chat_1_echo",
"game_chat_2_murmuration",
"game_chat_3_orbit",
"game_chat_4_courier",
"game_chat_5_glider",
"game_chat_6_tidepainter",
"game_claude_1_light",
"game_claude_2_moth",
"game_claude_3_bureaucromancer",
"game_claude_4_decibel",
"game_claude_5_cartographer",
"game_claude_6_flame",
"game_gemini_1_static",
"game_gemini_2_patch",
"game_gemini_3_suture",
"game_gemini_4_substratum",
"game_gemini_5_rename",
"game_gemini_6_redact"
)
# make a function to generate the blocks. i had chatgpt help me generate this code
set.seed(2026)
generate_blocks <- function(items) {
repeat {
# step 1: assign total target frequencies (15 items get 7, 3 get 6)
target_counts <- rep(7, length(items))
target_counts[sample(seq_along(items), 3)] <- 6
names(target_counts) <- items
# step 2: create pool
pool <- rep(items, target_counts)
# step 3: shuffle
pool <- sample(pool)
# step 4: form 41 blocks
blocks <- matrix(pool, ncol = 3, byrow = TRUE)
# check 1: no duplicate items within any block
if (any(apply(blocks, 1, function(row) length(unique(row)) < 3))) next
# check 2: all blocks unique
if (nrow(unique(blocks)) != 41) next
# check 3: positional balance constraint
pos_counts <- lapply(1:3, function(pos) table(blocks[, pos]))
ok_position <- TRUE
for (item in items) {
counts <- sapply(pos_counts, function(x) ifelse(item %in% names(x), x[item], 0))
if (max(counts) - min(counts) > 2) {
ok_position <- FALSE
break
}
}
if (!ok_position) next
return(as.data.frame(blocks))
}
}
blocks_df <- generate_blocks(items)
# make a function to generate the blocks. i had chatgpt help me generate this code
set.seed(2026)
generate_blocks <- function(items) {
repeat {
# step 1: assign total target frequencies (15 items get 7, 3 get 6)
target_counts <- rep(7, length(items))
target_counts[sample(seq_along(items), 3)] <- 6
names(target_counts) <- items
# step 2: create pool
pool <- rep(items, target_counts)
# step 3: shuffle
pool <- sample(pool)
# step 4: form 41 blocks
blocks <- matrix(pool, ncol = 3, byrow = TRUE)
# check 1: no duplicate items within any block
if (any(apply(blocks, 1, function(row) length(unique(row)) < 3))) next
# check 2: all blocks unique
if (nrow(unique(blocks)) != 41) next
# check 3: positional balance constraint
pos_counts <- lapply(1:3, function(pos) table(blocks[, pos]))
ok_position <- TRUE
for (item in items) {
counts <- sapply(pos_counts, function(x) ifelse(item %in% names(x), x[item], 0))
if (max(counts) - min(counts) > 2) {
ok_position <- FALSE
break
}
}
if (!ok_position) next
return(as.data.frame(blocks))
}
}
blocks_df <- generate_blocks(items)
# make a function to generate the blocks. i had chatgpt help me generate this code
set.seed(2026)
generate_blocks <- function(items) {
# Step 1: Assign total frequencies
target_counts <- rep(7, length(items))
target_counts[sample(seq_along(items), 3)] <- 6
names(target_counts) <- items
remaining_counts <- target_counts
blocks <- list()
for (i in 1:41) {
# Only choose from items that still have remaining quota
available <- names(remaining_counts[remaining_counts > 0])
# Sample 3 distinct items
block <- sample(available, 3, replace = FALSE)
# Store block
blocks[[i]] <- block
# Reduce counts
remaining_counts[block] <- remaining_counts[block] - 1
}
blocks_df <- as.data.frame(do.call(rbind, blocks))
colnames(blocks_df) <- c("Game_1", "Game_2", "Game_3")
return(blocks_df)
}
blocks_df <- generate_blocks(items)
blocks_df <- generate_blocks(items)
blocks_df
View(blocks_df)
#| label: check frequencies for sanity
all_items_from_blocks <- unlist(blocks_df)
# count frequencies
item_counts_from_blocks <- table(all_items_from_blocks)
# print
item_counts_from_blocks
# now the different llms are pretty evenly distributed and each game appears 6-7 times. perfect!
#| label: export the blocks
write.csv(blocks_df, "game_blocks.csv")
#| label:
any(apply(blocks_df, 1, function(row) length(unique(row)) < 3))
