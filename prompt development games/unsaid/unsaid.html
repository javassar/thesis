<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNSAID - A Word Transformation Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
        }

        #gameCanvas {
            border: 2px solid #444;
            cursor: default;
            image-rendering: crisp-edges;
        }

        .title {
            color: #888;
            font-size: 24px;
            margin-bottom: 10px;
            letter-spacing: 8px;
        }

        .tagline {
            color: #666;
            font-size: 12px;
            margin-bottom: 20px;
            font-style: italic;
        }

        .instructions {
            color: #666;
            font-size: 11px;
            margin-top: 15px;
            max-width: 900px;
            text-align: center;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="title">UNSAID</div>
    <div class="tagline">"You can't take it back. But you can take it apart."</div>
    <canvas id="gameCanvas" width="900" height="600"></canvas>
    <div class="instructions">
        Click and drag letters out of words. Arrange them horizontally to form new words.<br>
        Transform harsh words into kinder ones. Build a bridge between two silhouettes.
    </div>

    <script>
        // ============================================================
        // CONSTANTS AND CONFIGURATION
        // ============================================================

        const CANVAS_WIDTH = 900;
        const CANVAS_HEIGHT = 600;
        const LETTER_SIZE = 40;
        const GRAVITY = 100;
        const POSITIVE_RISE = -40;
        const NEGATIVE_SINK = 60;

        // Particle system
        const particles = [];
        const textCallouts = [];

        // Word dictionaries
        const POSITIVE_WORDS = new Set([
            "LOVE", "LOVED", "HEAR", "HEARD", "HEART", "STAY", "HERE", "NEAR", "HOPE", "SAVE", "SAVED",
            "CARE", "CARED", "DEAR", "DREAM", "WARM", "HEAL", "HELP", "SAFE", "SHARE", "LISTEN", "TENDER",
            "TRUE", "TRUST", "GENTLE", "HONEST", "HOLD", "HELD", "THREAD", "REACH", "TOGETHER", "FORGIVE",
            "BRIDGE", "CONNECT", "BETWEEN", "GIVE", "LIVE", "GROW", "GROWN"
        ]);

        const NEGATIVE_WORDS = new Set([
            "HATE", "HATED", "NEVER", "WRONG", "LEAVE", "ALONE", "BLAME", "BLAMED", "HURT", "ANGER",
            "RAGE", "CRUEL", "HARSH", "COLD", "GONE", "LOST", "FAULT", "SILENT", "SPITE", "SEVER",
            "RESENT", "REGRET", "BITTER", "HATRED", "DEATH", "DEARTH"
        ]);

        const BRIDGE_WORDS = new Set([
            "BRIDGE", "CONNECT", "REACH", "THREAD", "TOGETHER", "FORGIVE", "BETWEEN"
        ]);

        const VALID_WORDS = new Set([
            // Core emotional words
            "LOVE", "LOVED", "HATE", "HATED", "HEART", "HEAR", "HEARD", "HEAT",
            "NEVER", "EVER", "EVEN", "NEAR", "EARN", "LEAN", "LANE", "VEER",
            "WRONG", "GROW", "GROWN", "WORN", "GOWN", "ROW", "OWN", "NOW", "WON",
            "LEAVE", "HAVE", "SAVE", "GAVE", "VALE", "VEAL", "LAVE", "EAVE", "AVE",
            "ALONE", "ATONE", "LOAN", "LANE", "LEAN", "LONE", "ONE", "ON", "NO",
            "BLAME", "LAME", "MALE", "MEAL", "BALM", "LAMB", "LAM", "LAB", "ALE",
            "SILENT", "LISTEN", "TINSEL", "INLETS", "ENLIST", "ISLET", "TILES",
            "ANGER", "RANGE", "NEAR", "EARN", "GEAR", "RAGE", "ARE", "EAR", "ERA",
            "THREAD", "DEARTH", "HATRED", "HEART", "EARTH", "HATED", "DEATH",
            "TRADE", "RATED", "TREAD", "TREAT", "DATER", "HATER", "DEAR", "DARE",
            "READ", "RATE", "DATE", "HATE", "HEAT", "HEAD", "HARE", "HEAR", "TEAR",
            "RESENT", "TENDER", "RESTED", "NESTED", "DESERT", "ENTERS",
            "TREES", "STEER", "RESET", "TERSE", "STERN", "TEENS", "DENSE",
            "SEVER", "SERVE", "VERSE", "VEERS", "SEERS", "SEER", "EVER", "REVS",
            "WORDS", "SWORD", "DROWS", "ROWS", "WORD", "RODS",
            "REACH", "CHARE", "RACER", "CARER", "ACRE", "CARE", "RACE", "EACH",
            "ARCH", "CHAR", "ACHE", "HARE", "HEAR", "ACE", "ARC", "ARE", "EAR",
            "TOGETHER", "TETHER", "HOTTER", "GETTER", "GREET", "OTHER", "THREE",
            "FORGIVE", "GIVE", "FIVE", "FORGE", "RIFE", "OGRE", "GIVER", "GRIEF",
            "BRIDGE", "RIDGE", "BRIDE", "DIRGE", "GIRD", "BIRD", "RID", "BIG",
            "CRUEL", "ULCER", "LURE", "RULE", "CURL", "CURE", "CUR", "CUE",
            "TRUST", "STRUT", "RUST", "RUTS", "TUTS", "NUTS", "STUN", "RUNS",
            "HARSH", "RASH", "HASH", "SASH", "ASH", "HAS", "AH",
            "SORRY", "ROSY", "ORE",
            "STAY", "TAYS", "SWAY", "WAYS", "SAY", "YAW", "AT", "AS",
            "GONE", "ONE", "EGO", "EON", "GO", "ON", "NO",
            "HELP", "YELP",
            "HOPE", "HOPS", "POSH", "SHOP", "HOP", "HO", "OH",
            "HERE", "HEED", "DEER", "REED", "HER", "HE", "RE",
            "HOLD", "HELD", "DOLE", "OLD",
            "TRUE", "TRUES", "RUE", "RUT",
            "WARM", "WARMS", "SWARM", "ARMS", "MARS", "RAMS", "WAR", "ARM", "MAR",
            "SAFE", "SAFES",
            "COLD", "CLOD", "COD", "OLD", "COL",
            "LOST", "LOTS", "SLOT", "SOT", "LOT",
            "HURT", "RUTH", "RUTS", "HUT", "RUT",
            "NEAR", "EARN", "SEAR", "EARS", "ERAS", "ARE", "EAR", "ERA",
            "GENTLE", "LENT", "GLEN", "GLEE", "TEEN", "GENE",
            "HONEST", "HONES", "SHONE", "STONE", "TONES", "NOTES", "ONSET",
            "SHARE", "SHEAR", "HARES", "HEARS", "RASH", "SEAR",
            "DREAM", "ARMED", "DARER", "RARED", "READ", "MADE", "DARE", "DAME",
            "CARE", "CARED", "RACED", "CEDAR", "ARCED", "ACRE", "RACE",
            "DEAR", "DARE", "READ", "EARED", "DARER",
            "TIME", "MITE", "ITEM", "EMIT", "TIE", "IT", "ME",
            "HEAL", "HALE", "ALE", "LEA",
            "SPEAK", "PEAKS", "PEASE", "SEPAL", "LEAPS", "PEALS", "PLEAS",
            "MEANT", "NAMES", "MANES", "AMENS",
            "MORE", "ROME", "OMER", "ORE", "ROE",
            "LIVE", "VILE", "EVIL", "VEIL",
            "GIVE", "VIBE",
            // Two letter words
            "AT", "TO", "IT", "IS", "AS", "BE", "BY", "DO", "GO", "HE", "IF",
            "IN", "ME", "MY", "NO", "OF", "ON", "OR", "SO", "UP", "US", "WE",
            "AN", "AM", "AH", "AW", "BI", "EN", "HI", "HO", "ID",
            "LO", "MA", "OW", "PA", "PI", "RE", "SH", "UM", "UN"
        ]);

        const ENDING_TEXT = {
            "FORGIVE": "Some words take time.",
            "THREAD": "Some things remain connected.",
            "HEART": "Some things survive.",
            "LISTEN": "Some things were always there.",
            "TOGETHER": "Some things are possible.",
            "BRIDGE": "Some things can be built.",
            "LOVE": "Some things endure.",
            "HEAL": "Some things mend.",
            "REACH": "Some things span the distance.",
            "DEFAULT": "Some words are enough."
        };

        // ============================================================
        // LEVEL DATA
        // ============================================================

        const LEVEL_DATA = {
            1: {
                name: "First Words",
                left_silhouette: {x: 50, y: 450},
                right_silhouette: {x: 800, y: 450},
                platforms: [
                    {x: 0, y: 500, width: 200, height: 30},
                    {x: 700, y: 500, width: 200, height: 30}
                ],
                starting_words: [
                    {word: "HATRED", x: 350, y: 200}
                ],
                ambient_letters: [],
                hint_text: "Drag letters out of words. Arrange them to build something new.",
                hint_delay: 15,
                win_condition: "bridge"
            },
            2: {
                name: "The Silence",
                left_silhouette: {x: 50, y: 450},
                right_silhouette: {x: 800, y: 450},
                platforms: [
                    {x: 0, y: 500, width: 200, height: 30},
                    {x: 700, y: 500, width: 200, height: 30}
                ],
                starting_words: [
                    {word: "SILENT", x: 370, y: 150}
                ],
                ambient_letters: [],
                hint_text: "The same letters can spell different truths.",
                hint_delay: 12,
                win_condition: "reach_silhouette"
            },
            3: {
                name: "Misdirection",
                left_silhouette: {x: 50, y: 350},
                right_silhouette: {x: 800, y: 350},
                platforms: [
                    {x: 0, y: 400, width: 200, height: 30},
                    {x: 700, y: 400, width: 200, height: 30}
                ],
                starting_words: [
                    {word: "BLAME", x: 395, y: 100},
                    {word: "ANGER", x: 395, y: 200},
                    {word: "WRONG", x: 395, y: 300}
                ],
                ambient_letters: [],
                hint_text: null,
                win_condition: "reach_silhouette"
            },
            4: {
                name: "The Cost",
                left_silhouette: {x: 50, y: 450},
                right_silhouette: {x: 800, y: 450},
                platforms: [
                    {x: 0, y: 500, width: 200, height: 30},
                    {x: 350, y: 400, width: 200, height: 30},
                    {x: 700, y: 500, width: 200, height: 30}
                ],
                starting_words: [
                    {word: "SEVER", x: 380, y: 350},
                    {word: "LOVE", x: 420, y: 100}
                ],
                ambient_letters: [
                    {char: "L", x: 250, y: 250},
                    {char: "I", x: 290, y: 270},
                    {char: "F", x: 320, y: 240},
                    {char: "E", x: 360, y: 260}
                ],
                hint_text: "Some things require building, not just destroying.",
                hint_delay: 20,
                win_condition: "touch_love"
            },
            5: {
                name: "Last Word",
                left_silhouette: {x: 300, y: 400},
                right_silhouette: {x: 550, y: 400},
                platforms: [
                    {x: 200, y: 450, width: 150, height: 30},
                    {x: 500, y: 450, width: 150, height: 30}
                ],
                starting_words: [],
                ambient_letters: [
                    {char: "F", x: 350, y: 100},
                    {char: "O", x: 420, y: 120},
                    {char: "R", x: 380, y: 90},
                    {char: "G", x: 450, y: 150},
                    {char: "I", x: 400, y: 180},
                    {char: "V", x: 360, y: 140},
                    {char: "E", x: 430, y: 110},
                    {char: "T", x: 340, y: 200},
                    {char: "H", x: 480, y: 130},
                    {char: "R", x: 320, y: 170},
                    {char: "E", x: 460, y: 190},
                    {char: "A", x: 390, y: 160},
                    {char: "D", x: 410, y: 140},
                    {char: "S", x: 370, y: 220},
                    {char: "L", x: 440, y: 200},
                    {char: "N", x: 350, y: 130}
                ],
                drift_speed: 5,
                hint_text: null,
                win_condition: "any_bridge"
            }
        };

        // ============================================================
        // GAME STATE
        // ============================================================

        class Letter {
            constructor(x, y, char) {
                this.x = x;
                this.y = y;
                this.char = char;
                this.state = "FREE"; // FREE, IN_WORD, ACTIVATED
                this.parent_word = null;
                this.velocity_y = 0;
                this.velocity_x = 0;
                this.home_x = x;
                this.home_y = y;
                this.shake = 0;
            }
        }

        class Particle {
            constructor(x, y, color, type = "spark") {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 150;
                this.vy = (Math.random() - 0.5) * 150 - 50;
                this.life = 1.0;
                this.color = color;
                this.type = type;
                this.size = Math.random() * 3 + 2;
            }

            update(delta) {
                this.x += this.vx * delta;
                this.y += this.vy * delta;
                this.vy += GRAVITY * delta * 0.5;
                this.life -= delta * 2;
            }
        }

        class TextCallout {
            constructor(text, x, y, color = '#FFD700') {
                this.text = text;
                this.x = x;
                this.y = y;
                this.startY = y;
                this.life = 1.5;
                this.color = color;
            }

            update(delta) {
                this.life -= delta;
                this.y = this.startY - (1.5 - this.life) * 30; // Float upward
            }
        }

        class Word {
            constructor(x, y, letters, text) {
                this.x = x;
                this.y = y;
                this.letters = letters;
                this.text = text;
                this.type = this.getWordType(text);
                this.velocity_y = 0;
                this.state = "ACTIVE";
                this.glow_phase = 0;
            }

            getWordType(text) {
                if (BRIDGE_WORDS.has(text)) return "bridge";
                if (POSITIVE_WORDS.has(text)) return "positive";
                if (NEGATIVE_WORDS.has(text)) return "negative";
                return "neutral";
            }
        }

        const game = {
            current_level: 1,
            letters: [],
            words: [],
            platforms: [],
            silhouettes: {
                left: {posture: "NEUTRAL"},
                right: {posture: "NEUTRAL"}
            },
            atmosphere: 0,
            selected_letter: null,
            drag_offset: {x: 0, y: 0},
            game_phase: "PLAYING", // PLAYING, TRANSITIONING, ENDING
            ending_word: "",
            ending_timer: 0,
            hint_text: null,
            hint_timer: 0,
            show_hint: false,
            level_data: null,
            flash_alpha: 0,
            shake_intensity: 0,
            celebration_timer: 0,
            celebrating_word: null,
            tutorial_alpha: 1.0,
            has_extracted_letter: false,
            transition_alpha: 0,
            transition_text: ""
        };

        // ============================================================
        // INITIALIZATION
        // ============================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let lastTime = performance.now();

        function init() {
            loadLevel(1);
            requestAnimationFrame(gameLoop);
        }

        function loadLevel(levelNum) {
            const data = LEVEL_DATA[levelNum];
            game.level_data = data;
            game.current_level = levelNum;

            // Clear state
            game.letters = [];
            game.words = [];
            game.platforms = data.platforms;
            game.atmosphere = 0;
            game.selected_letter = null;
            game.game_phase = "PLAYING";
            game.hint_text = data.hint_text;
            game.hint_timer = 0;
            game.show_hint = false;
            game.flash_alpha = 0;
            game.shake_intensity = 0;
            game.celebration_timer = 0;
            game.celebrating_word = null;
            game.tutorial_alpha = levelNum === 1 ? 1.0 : 0;
            game.has_extracted_letter = false;
            game.transition_alpha = 0;
            game.transition_text = "";
            particles.length = 0;
            textCallouts.length = 0;

            // Setup silhouettes
            game.silhouettes.left = {...data.left_silhouette, posture: "NEUTRAL"};
            game.silhouettes.right = {...data.right_silhouette, posture: "NEUTRAL"};

            // Create starting words
            data.starting_words.forEach(wordData => {
                createStartingWord(wordData);
            });

            // Create ambient letters
            data.ambient_letters.forEach(letterData => {
                const letter = new Letter(letterData.x, letterData.y, letterData.char);
                game.letters.push(letter);
            });
        }

        function createStartingWord(data) {
            const letters = [];
            for (let i = 0; i < data.word.length; i++) {
                const letter = new Letter(
                    data.x + i * LETTER_SIZE,
                    data.y,
                    data.word[i]
                );
                letter.state = "IN_WORD";
                letters.push(letter);
            }

            const word = new Word(data.x, data.y, letters, data.word);
            letters.forEach(l => l.parent_word = word);
            game.words.push(word);
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Check if in ending and clicking to restart
            if (game.game_phase === "ENDING" && game.ending_timer > 11.0) {
                loadLevel(1);
                return;
            }

            // Check free letters first
            for (let i = game.letters.length - 1; i >= 0; i--) {
                const letter = game.letters[i];
                if (letter.state === "FREE" && pointInRect(mouseX, mouseY, letter.x, letter.y, LETTER_SIZE, LETTER_SIZE)) {
                    game.selected_letter = letter;
                    game.drag_offset.x = mouseX - letter.x;
                    game.drag_offset.y = mouseY - letter.y;
                    return;
                }
            }

            // Check letters in words
            for (let word of game.words) {
                for (let letter of word.letters) {
                    if (pointInRect(mouseX, mouseY, letter.x, letter.y, LETTER_SIZE, LETTER_SIZE)) {
                        extractLetterFromWord(letter, word);
                        game.selected_letter = letter;
                        game.drag_offset.x = mouseX - letter.x;
                        game.drag_offset.y = mouseY - letter.y;
                        game.has_extracted_letter = true;
                        return;
                    }
                }
            }
        }

        function handleMouseMove(e) {
            if (game.selected_letter) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Update position with bounds checking
                let newX = mouseX - game.drag_offset.x;
                let newY = mouseY - game.drag_offset.y;

                // Clamp to screen boundaries
                newX = Math.max(0, Math.min(newX, CANVAS_WIDTH - LETTER_SIZE));
                newY = Math.max(0, Math.min(newY, CANVAS_HEIGHT - LETTER_SIZE));

                game.selected_letter.x = newX;
                game.selected_letter.y = newY;
            }
        }

        function handleMouseUp(e) {
            if (game.selected_letter) {
                game.selected_letter.state = "FREE";
                game.selected_letter = null;
                checkWordFormation();
            }
        }

        function pointInRect(px, py, rx, ry, rw, rh) {
            return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
        }

        // ============================================================
        // WORD MECHANICS
        // ============================================================

        function extractLetterFromWord(letter, word) {
            // Remove letter from word
            const index = word.letters.indexOf(letter);
            if (index > -1) {
                word.letters.splice(index, 1);
            }

            letter.state = "FREE";
            letter.parent_word = null;
            game.letters.push(letter);

            // Check remaining letters
            const remainingText = word.letters.map(l => l.char).join('');

            if (remainingText.length > 0 && VALID_WORDS.has(remainingText)) {
                // Word transforms
                word.text = remainingText;
                word.type = word.getWordType(remainingText);
                recalculateWordPositions(word);
            } else if (word.letters.length > 0) {
                // Word dissolves - create particles
                const centerX = word.x + (word.letters.length * LETTER_SIZE) / 2;
                const centerY = word.y + LETTER_SIZE / 2;

                // Create particle explosion
                const particleColor = word.type === "negative" ? '#8B0000' :
                                     word.type === "positive" ? '#90EE90' : '#888888';
                for (let i = 0; i < 12; i++) {
                    particles.push(new Particle(centerX, centerY, particleColor));
                }

                word.letters.forEach(l => {
                    l.state = "FREE";
                    l.parent_word = null;
                    l.velocity_y = Math.random() * 100 - 50;
                    l.velocity_x = Math.random() * 60 - 30;
                    l.shake = 0.3;
                    game.letters.push(l);
                });
                const wordIndex = game.words.indexOf(word);
                if (wordIndex > -1) {
                    game.words.splice(wordIndex, 1);
                }
            } else {
                // No letters left
                const wordIndex = game.words.indexOf(word);
                if (wordIndex > -1) {
                    game.words.splice(wordIndex, 1);
                }
            }
        }

        function recalculateWordPositions(word) {
            word.letters.forEach((letter, i) => {
                letter.x = word.x + i * LETTER_SIZE;
                letter.y = word.y;
            });
        }

        function checkWordFormation() {
            if (game.selected_letter) return;

            const freeLetters = game.letters.filter(l => l.state === "FREE");

            // Sort by x position
            freeLetters.sort((a, b) => a.x - b.x);

            // Find horizontal chains
            const chains = [];
            let currentChain = [];

            for (let letter of freeLetters) {
                if (currentChain.length === 0) {
                    currentChain = [letter];
                } else {
                    const last = currentChain[currentChain.length - 1];
                    // Adjacent if within 25px horizontally and 8px vertically (tighter snapping)
                    if (Math.abs(letter.x - (last.x + LETTER_SIZE)) < 25 && Math.abs(letter.y - last.y) < 8) {
                        currentChain.push(letter);
                    } else {
                        if (currentChain.length >= 2) {
                            chains.push([...currentChain]);
                        }
                        currentChain = [letter];
                    }
                }
            }

            if (currentChain.length >= 2) {
                chains.push(currentChain);
            }

            // Check each chain
            for (let chain of chains) {
                const text = chain.map(l => l.char).join('');
                if (VALID_WORDS.has(text)) {
                    createWordFromChain(chain, text);
                }
            }
        }

        function createWordFromChain(chain, text) {
            const word = new Word(chain[0].x, chain[0].y, chain, text);

            chain.forEach(letter => {
                letter.state = "ACTIVATED";
                letter.parent_word = word;
                const index = game.letters.indexOf(letter);
                if (index > -1) {
                    game.letters.splice(index, 1);
                }
            });

            game.words.push(word);

            // Celebrate meaningful words
            if (word.type === "bridge" || word.type === "positive") {
                celebrateWord(word);
            }
        }

        function celebrateWord(word) {
            game.celebration_timer = 1.5;
            game.celebrating_word = word;

            // Create celebratory particles
            const centerX = word.x + (word.text.length * LETTER_SIZE) / 2;
            const centerY = word.y + LETTER_SIZE / 2;

            const particleColor = word.type === "bridge" ? '#FFD700' : '#90EE90';

            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(centerX, centerY, particleColor));
            }

            // Flash effect
            game.flash_alpha = 0.3;

            // Text callout for special words
            const specialWords = {
                "FORGIVE": "♥",
                "THREAD": "✦",
                "LISTEN": "✧",
                "HEART": "♥",
                "BRIDGE": "═",
                "TOGETHER": "∞",
                "LOVE": "♥",
                "REACH": "→"
            };

            if (specialWords[word.text]) {
                textCallouts.push(new TextCallout(
                    specialWords[word.text],
                    centerX,
                    centerY - 30,
                    particleColor
                ));
            }
        }

        // ============================================================
        // PHYSICS
        // ============================================================

        function updatePhysics(delta) {
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update(delta);
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Update text callouts
            for (let i = textCallouts.length - 1; i >= 0; i--) {
                const tc = textCallouts[i];
                tc.update(delta);
                if (tc.life <= 0) {
                    textCallouts.splice(i, 1);
                }
            }

            // Update celebration timer
            if (game.celebration_timer > 0) {
                game.celebration_timer -= delta;
            }

            // Fade tutorial in level 1
            if (game.current_level === 1 && game.has_extracted_letter && game.tutorial_alpha > 0) {
                game.tutorial_alpha -= delta * 0.5;
                game.tutorial_alpha = Math.max(0, game.tutorial_alpha);
            }

            // Update flash
            if (game.flash_alpha > 0) {
                game.flash_alpha -= delta * 2;
                game.flash_alpha = Math.max(0, game.flash_alpha);
            }

            // Update shake
            if (game.shake_intensity > 0) {
                game.shake_intensity -= delta * 3;
                game.shake_intensity = Math.max(0, game.shake_intensity);
            }

            // Update free letters
            for (let letter of game.letters) {
                if (letter.state === "FREE" && letter !== game.selected_letter) {
                    // Apply physics
                    letter.velocity_y += GRAVITY * delta;
                    letter.y += letter.velocity_y * delta;
                    letter.x += letter.velocity_x * delta;

                    // Decay horizontal velocity
                    letter.velocity_x *= (1 - delta * 2);

                    // Decay shake
                    if (letter.shake > 0) {
                        letter.shake -= delta * 2;
                        letter.shake = Math.max(0, letter.shake);
                    }

                    // Safety check: if letter somehow got way off screen, reset to visible area
                    if (letter.x < -100 || letter.x > CANVAS_WIDTH + 100 ||
                        letter.y < -100 || letter.y > CANVAS_HEIGHT + 100) {
                        // Reset to a safe position in the middle of screen
                        letter.x = CANVAS_WIDTH / 2 - LETTER_SIZE / 2 + (Math.random() - 0.5) * 100;
                        letter.y = 100;
                        letter.velocity_x = 0;
                        letter.velocity_y = 0;
                    }

                    // Check platform collision
                    for (let platform of game.platforms) {
                        if (letter.x + LETTER_SIZE > platform.x &&
                            letter.x < platform.x + platform.width &&
                            letter.y + LETTER_SIZE >= platform.y &&
                            letter.y + LETTER_SIZE <= platform.y + platform.height + 10) {
                            letter.y = platform.y - LETTER_SIZE;
                            letter.velocity_y = 0;
                        }
                    }

                    // Level 5 drift
                    if (game.current_level === 5 && game.level_data.drift_speed) {
                        const dx = letter.x - letter.home_x;
                        const dy = letter.y - letter.home_y;
                        letter.x += Math.sign(dx) * game.level_data.drift_speed * delta * 0.3;
                        letter.y += Math.sign(dy) * game.level_data.drift_speed * delta * 0.3;
                    }

                    // Keep on screen - bottom boundary
                    if (letter.y + LETTER_SIZE > CANVAS_HEIGHT) {
                        letter.y = CANVAS_HEIGHT - LETTER_SIZE;
                        letter.velocity_y = 0;
                        letter.velocity_x *= 0.8; // Dampen horizontal movement when on ground
                    }

                    // Keep on screen - side boundaries
                    if (letter.x < 0) {
                        letter.x = 0;
                        letter.velocity_x = 0;
                    }
                    if (letter.x + LETTER_SIZE > CANVAS_WIDTH) {
                        letter.x = CANVAS_WIDTH - LETTER_SIZE;
                        letter.velocity_x = 0;
                    }

                    // Keep on screen - top boundary (for level 5 drift)
                    if (letter.y < 0) {
                        letter.y = 0;
                        letter.velocity_y = 0;
                    }
                }
            }

            // Update words
            for (let word of game.words) {
                word.glow_phase += delta * 3;

                switch (word.type) {
                    case "positive":
                        word.velocity_y = POSITIVE_RISE;
                        word.y += word.velocity_y * delta;
                        word.y = Math.max(word.y, 50);
                        break;

                    case "negative":
                        word.velocity_y += NEGATIVE_SINK * delta;
                        word.y += word.velocity_y * delta;
                        checkWordPlatformCollision(word);
                        break;

                    case "bridge":
                        // Float toward center
                        const targetX = (game.silhouettes.left.x + game.silhouettes.right.x) / 2 - (word.text.length * LETTER_SIZE) / 2;
                        const targetY = game.silhouettes.left.y - 80;
                        word.x += (targetX - word.x) * 2 * delta;
                        word.y += (targetY - word.y) * 2 * delta;
                        break;

                    case "neutral":
                        word.velocity_y += GRAVITY * delta;
                        word.y += word.velocity_y * delta;
                        checkWordPlatformCollision(word);
                        break;
                }

                // Keep words on screen - prevent them from falling off
                if (word.y + LETTER_SIZE > CANVAS_HEIGHT) {
                    word.y = CANVAS_HEIGHT - LETTER_SIZE;
                    word.velocity_y = 0;
                }

                // Keep words on screen horizontally
                const wordWidth = word.text.length * LETTER_SIZE;
                if (word.x < 0) {
                    word.x = 0;
                }
                if (word.x + wordWidth > CANVAS_WIDTH) {
                    word.x = CANVAS_WIDTH - wordWidth;
                }

                // Update letter positions within word
                word.letters.forEach((letter, i) => {
                    letter.x = word.x + i * LETTER_SIZE;
                    letter.y = word.y;
                });
            }
        }

        function checkWordPlatformCollision(word) {
            const wordWidth = word.text.length * LETTER_SIZE;

            for (let platform of game.platforms) {
                if (word.x + wordWidth > platform.x &&
                    word.x < platform.x + platform.width &&
                    word.y + LETTER_SIZE >= platform.y &&
                    word.y + LETTER_SIZE <= platform.y + platform.height + 10) {
                    word.y = platform.y - LETTER_SIZE;
                    word.velocity_y = 0;
                }
            }
        }

        // ============================================================
        // ATMOSPHERE
        // ============================================================

        function updateAtmosphere() {
            let targetAtmosphere = 0;

            for (let word of game.words) {
                if (word.type === "positive" || word.type === "bridge") {
                    targetAtmosphere += 0.3;
                } else if (word.type === "negative") {
                    targetAtmosphere -= 0.3;
                }
            }

            targetAtmosphere = Math.max(-1.0, Math.min(1.0, targetAtmosphere));
            game.atmosphere += (targetAtmosphere - game.atmosphere) * 0.02;

            // Update silhouette postures
            if (game.atmosphere > 0.3) {
                game.silhouettes.left.posture = "TOWARD";
                game.silhouettes.right.posture = "TOWARD";
            } else if (game.atmosphere < -0.3) {
                game.silhouettes.left.posture = "AWAY";
                game.silhouettes.right.posture = "AWAY";
            } else {
                game.silhouettes.left.posture = "NEUTRAL";
                game.silhouettes.right.posture = "NEUTRAL";
            }
        }

        // ============================================================
        // WIN CONDITIONS
        // ============================================================

        function checkWinCondition() {
            if (game.game_phase !== "PLAYING") return;

            const condition = game.level_data.win_condition;

            switch (condition) {
                case "bridge":
                    for (let word of game.words) {
                        if (word.type === "bridge") {
                            triggerLevelComplete(word.text);
                            return;
                        }
                    }
                    break;

                case "reach_silhouette":
                    for (let word of game.words) {
                        if (word.type === "positive" || word.type === "neutral" || word.type === "bridge") {
                            if (wordReachesSilhouette(word)) {
                                triggerLevelComplete(word.text);
                                return;
                            }
                        }
                    }
                    break;

                case "touch_love":
                    // Check if player created LIVE which rises toward LOVE
                    const liveWord = game.words.find(w => w.text === "LIVE");
                    const loveWord = game.words.find(w => w.text === "LOVE");

                    if (liveWord && loveWord) {
                        // Check if LIVE has risen close enough to LOVE
                        const distance = Math.sqrt(
                            Math.pow(liveWord.x - loveWord.x, 2) +
                            Math.pow(liveWord.y - loveWord.y, 2)
                        );
                        if (distance < 120) {
                            triggerLevelComplete("LOVE");
                            return;
                        }
                    }

                    // Alternative: any positive word creates a bridge to LOVE's platform
                    if (loveWord) {
                        for (let word of game.words) {
                            if ((word.type === "positive" || word.type === "neutral") &&
                                word !== loveWord &&
                                Math.abs(word.y - 100) < 50 &&  // Near LOVE's height
                                Math.abs(word.x + word.text.length * LETTER_SIZE - loveWord.x) < 80) {
                                triggerLevelComplete("LOVE");
                                return;
                            }
                        }
                    }
                    break;

                case "any_bridge":
                    for (let word of game.words) {
                        if (word.type === "bridge" || word.type === "positive") {
                            if (wordSpansGap(word)) {
                                triggerEnding(word.text);
                                return;
                            }
                        }
                    }
                    break;
            }
        }

        function wordReachesSilhouette(word) {
            const wordRight = word.x + word.text.length * LETTER_SIZE;
            const silRight = game.silhouettes.right.x;

            return wordRight >= silRight - 100 &&
                   word.x <= silRight + 50 &&
                   Math.abs(word.y - game.silhouettes.right.y) < 100;
        }

        function wordSpansGap(word) {
            const wordLeft = word.x;
            const wordRight = word.x + word.text.length * LETTER_SIZE;
            const silLeft = game.silhouettes.left.x;
            const silRight = game.silhouettes.right.x;

            return wordLeft <= silLeft + 50 && wordRight >= silRight - 50;
        }

        function triggerLevelComplete(wordText) {
            game.game_phase = "TRANSITIONING";
            game.transition_text = wordText;
            game.transition_alpha = 0;

            // Animate transition
            const startTime = performance.now();
            const transitionDuration = 2500;

            const animateTransition = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = elapsed / transitionDuration;

                if (progress < 0.4) {
                    // Fade to white
                    game.transition_alpha = progress / 0.4;
                } else if (progress < 0.6) {
                    // Hold white
                    game.transition_alpha = 1.0;
                } else if (progress < 1.0) {
                    // Fade from white
                    game.transition_alpha = 1.0 - ((progress - 0.6) / 0.4);
                } else {
                    // Complete transition
                    if (game.current_level < 5) {
                        loadLevel(game.current_level + 1);
                    } else {
                        triggerEnding(wordText);
                    }
                    return;
                }

                requestAnimationFrame(animateTransition);
            };

            requestAnimationFrame(animateTransition);
        }

        function triggerEnding(finalWord) {
            game.game_phase = "ENDING";
            game.ending_word = finalWord;
            game.ending_timer = 0;

            // Make silhouettes turn toward each other
            setTimeout(() => {
                game.silhouettes.left.posture = "TOWARD";
                game.silhouettes.right.posture = "TOWARD";
            }, 500);
        }

        // ============================================================
        // RENDERING
        // ============================================================

        function render() {
            // Background gradient based on atmosphere - more dramatic
            let bgColor1, bgColor2;
            if (game.atmosphere < 0) {
                // Negative atmosphere: cold, dark blue to dark red
                bgColor1 = lerpColor(
                    {r: 30, g: 35, b: 50},
                    {r: 50, g: 20, b: 25},
                    Math.abs(game.atmosphere)
                );
                bgColor2 = lerpColor(
                    {r: 15, g: 18, b: 30},
                    {r: 30, g: 10, b: 15},
                    Math.abs(game.atmosphere)
                );
            } else {
                // Positive atmosphere: neutral to warm golden
                bgColor1 = lerpColor(
                    {r: 30, g: 35, b: 50},
                    {r: 70, g: 55, b: 35},
                    game.atmosphere
                );
                bgColor2 = lerpColor(
                    {r: 15, g: 18, b: 30},
                    {r: 45, g: 35, b: 20},
                    game.atmosphere
                );
            }

            // Create vertical gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            gradient.addColorStop(0, `rgb(${bgColor1.r}, ${bgColor1.g}, ${bgColor1.b})`);
            gradient.addColorStop(1, `rgb(${bgColor2.r}, ${bgColor2.g}, ${bgColor2.b})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Add atmospheric particles/motes
            if (game.atmosphere > 0.2) {
                ctx.fillStyle = `rgba(255, 215, 100, ${game.atmosphere * 0.15})`;
                for (let i = 0; i < 30; i++) {
                    const x = (i * 137.5 + performance.now() * 0.01) % CANVAS_WIDTH;
                    const y = (i * 73.2 + performance.now() * 0.02) % CANVAS_HEIGHT;
                    ctx.fillRect(x, y, 2, 2);
                }
            } else if (game.atmosphere < -0.2) {
                ctx.fillStyle = `rgba(100, 100, 150, ${Math.abs(game.atmosphere) * 0.1})`;
                for (let i = 0; i < 20; i++) {
                    const x = (i * 157.3 + performance.now() * 0.008) % CANVAS_WIDTH;
                    const y = (i * 89.7 + performance.now() * 0.015) % CANVAS_HEIGHT;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            // Draw light beams from positive words
            for (let word of game.words) {
                if (word.type === "positive" || word.type === "bridge") {
                    const centerX = word.x + (word.text.length * LETTER_SIZE) / 2;
                    const centerY = word.y + LETTER_SIZE / 2;

                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 150);
                    gradient.addColorStop(0, word.type === "bridge" ?
                        'rgba(255, 215, 0, 0.08)' : 'rgba(144, 238, 144, 0.05)');
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(centerX - 150, centerY - 150, 300, 300);
                }
            }

            // Draw platforms
            ctx.fillStyle = '#4a4a5a';
            for (let platform of game.platforms) {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            }

            // Draw silhouettes
            drawSilhouette(game.silhouettes.left);
            drawSilhouette(game.silhouettes.right);

            // Draw words
            for (let word of game.words) {
                drawWord(word);
            }

            // Draw particles
            for (let particle of particles) {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // Draw free letters
            for (let letter of game.letters) {
                if (letter.state === "FREE") {
                    drawLetter(letter, letter === game.selected_letter);
                }
            }

            // Draw text callouts
            for (let tc of textCallouts) {
                ctx.save();
                ctx.globalAlpha = Math.min(tc.life, 1.0);
                ctx.fillStyle = tc.color;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 10;
                ctx.shadowColor = tc.color;
                ctx.fillText(tc.text, tc.x, tc.y);
                ctx.restore();
            }

            // Flash effect for celebrations
            if (game.flash_alpha > 0) {
                ctx.fillStyle = game.celebrating_word && game.celebrating_word.type === "bridge" ?
                    `rgba(255, 215, 0, ${game.flash_alpha})` :
                    `rgba(144, 238, 144, ${game.flash_alpha})`;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }

            // Draw hint
            if (game.show_hint && game.hint_text) {
                ctx.fillStyle = '#666666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText(game.hint_text, CANVAS_WIDTH / 2, 570);
            }

            // Draw level name
            ctx.fillStyle = '#888888';
            ctx.font = '18px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText(game.level_data.name, CANVAS_WIDTH / 2, 25);

            // Tutorial overlay for level 1
            if (game.current_level === 1 && game.tutorial_alpha > 0) {
                ctx.save();
                ctx.globalAlpha = game.tutorial_alpha * 0.7;

                // Dim background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Highlight HATRED word
                const hatredWord = game.words.find(w => w.text === "HATRED");
                if (hatredWord) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(hatredWord.x - 5, hatredWord.y - 5,
                                  hatredWord.text.length * LETTER_SIZE + 10,
                                  LETTER_SIZE + 10);
                    ctx.setLineDash([]);

                    // Draw instruction
                    ctx.fillStyle = '#FFD700';
                    ctx.font = '16px "Courier New"';
                    ctx.fillText('Click and drag letters from this word', CANVAS_WIDTH / 2, 300);
                    ctx.font = '14px "Courier New"';
                    ctx.fillText('Build something new from what was said', CANVAS_WIDTH / 2, 330);
                }

                ctx.restore();
            }

            // Level transition overlay
            if (game.game_phase === "TRANSITIONING" && game.transition_alpha > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${game.transition_alpha})`;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (game.transition_alpha > 0.8) {
                    ctx.save();
                    ctx.globalAlpha = game.transition_alpha;
                    ctx.fillStyle = '#1a1a1a';
                    ctx.font = '32px "Courier New"';
                    ctx.textAlign = 'center';
                    ctx.fillText(game.transition_text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    ctx.restore();
                }
            }

            // Ending overlay
            if (game.game_phase === "ENDING") {
                renderEnding();
            }
        }

        function drawSilhouette(sil) {
            const x = sil.x;
            const y = sil.y;

            // Add subtle glow based on atmosphere
            if (game.atmosphere > 0.3) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(144, 238, 144, 0.5)';
            } else if (game.atmosphere < -0.3) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(139, 0, 0, 0.5)';
            }

            ctx.fillStyle = '#1a1a1a';

            // Body with smooth posture transitions
            ctx.save();
            ctx.translate(x + 15, y - 30);

            if (sil.posture === "AWAY") {
                // Turned away - narrower, slightly rotated
                ctx.rotate(sil === game.silhouettes.left ? 0.1 : -0.1);
                ctx.fillRect(-10, -30, 20, 60);
            } else if (sil.posture === "TOWARD") {
                // Turned toward - full width, slight lean
                ctx.rotate(sil === game.silhouettes.left ? -0.05 : 0.05);
                ctx.fillRect(-15, -30, 30, 60);
                // Arms slightly forward
                ctx.fillStyle = '#0a0a0a';
                if (sil === game.silhouettes.left) {
                    ctx.fillRect(5, -20, 15, 8);
                } else {
                    ctx.fillRect(-20, -20, 15, 8);
                }
            } else {
                // Neutral
                ctx.fillRect(-15, -30, 30, 60);
            }

            ctx.restore();

            // Head with better shape
            ctx.beginPath();
            ctx.arc(x + 15, y - 80, 15, 0, Math.PI * 2);
            ctx.fill();

            // Reset shadow
            ctx.shadowBlur = 0;
        }

        function drawWord(word) {
            let glowAlpha = (Math.sin(word.glow_phase) + 1) / 4;

            // Intensify glow during celebration
            const isCelebrating = game.celebrating_word === word && game.celebration_timer > 0;
            if (isCelebrating) {
                glowAlpha = Math.max(glowAlpha, 0.6 + Math.sin(word.glow_phase * 5) * 0.3);
            }

            let glowColor;
            if (word.type === "positive") {
                glowColor = '#90EE90';
            } else if (word.type === "negative") {
                glowColor = '#8B0000';
            } else if (word.type === "bridge") {
                glowColor = '#FFD700';
            }

            if (glowColor) {
                // Enhanced glow with multiple layers
                ctx.shadowBlur = isCelebrating ? 25 : 10;
                ctx.shadowColor = glowColor;

                ctx.fillStyle = glowColor;
                ctx.globalAlpha = glowAlpha;
                const glowSize = isCelebrating ? 8 : 3;
                ctx.fillRect(word.x - glowSize, word.y - glowSize,
                           word.text.length * LETTER_SIZE + glowSize * 2,
                           LETTER_SIZE + glowSize * 2);
                ctx.globalAlpha = 1.0;
                ctx.shadowBlur = 0;
            }

            // Scale effect during celebration
            const scale = isCelebrating ? 1 + Math.sin(word.glow_phase * 5) * 0.05 : 1;

            ctx.save();
            if (scale !== 1) {
                const centerX = word.x + (word.text.length * LETTER_SIZE) / 2;
                const centerY = word.y + LETTER_SIZE / 2;
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.translate(-centerX, -centerY);
            }

            for (let i = 0; i < word.letters.length; i++) {
                drawLetterAt(word.x + i * LETTER_SIZE, word.y, word.letters[i].char, true);
            }

            ctx.restore();
        }

        function drawLetter(letter, selected) {
            drawLetterAt(letter.x, letter.y, letter.char, false, selected, letter.shake);
        }

        function drawLetterAt(x, y, char, inWord, selected = false, shake = 0) {
            // Apply shake offset
            const shakeX = shake > 0 ? (Math.random() - 0.5) * shake * 10 : 0;
            const shakeY = shake > 0 ? (Math.random() - 0.5) * shake * 10 : 0;

            const drawX = x + shakeX;
            const drawY = y + shakeY;

            ctx.fillStyle = selected ? '#FFD700' : '#e8e8e0';
            ctx.fillRect(drawX, drawY, LETTER_SIZE, LETTER_SIZE);

            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            ctx.strokeRect(drawX, drawY, LETTER_SIZE, LETTER_SIZE);

            ctx.fillStyle = '#333333';
            ctx.font = 'bold 24px "Courier New"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(char, drawX + LETTER_SIZE / 2, drawY + LETTER_SIZE / 2);
        }

        function renderEnding() {
            const overlayAlpha = Math.min(game.ending_timer / 2.0, 0.7);
            ctx.fillStyle = '#FFFFFF';
            ctx.globalAlpha = overlayAlpha;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.globalAlpha = 1.0;

            ctx.fillStyle = '#1a1a1a';
            ctx.textAlign = 'center';

            if (game.ending_timer > 1.0) {
                ctx.font = 'bold 48px "Courier New"';
                ctx.fillText(game.ending_word + ".", CANVAS_WIDTH / 2, 200);
            }

            if (game.ending_timer > 3.0) {
                const phrase = ENDING_TEXT[game.ending_word] || ENDING_TEXT.DEFAULT;
                ctx.font = '24px "Courier New"';
                ctx.fillStyle = '#333333';
                ctx.fillText(phrase, CANVAS_WIDTH / 2, 280);
            }

            if (game.ending_timer > 5.0) {
                ctx.font = '18px "Courier New"';
                ctx.fillStyle = '#666666';
                ctx.fillText("What we said can't be unsaid.", CANVAS_WIDTH / 2, 380);
            }

            if (game.ending_timer > 6.5) {
                ctx.fillText("But what we remember is ours to shape.", CANVAS_WIDTH / 2, 410);
            }

            if (game.ending_timer > 9.0) {
                ctx.font = '14px "Courier New"';
                ctx.fillStyle = '#888888';
                ctx.fillText("Thank you for playing.", CANVAS_WIDTH / 2, 500);
            }

            if (game.ending_timer > 11.0) {
                ctx.font = '12px "Courier New"';
                ctx.fillStyle = '#666666';
                ctx.fillText("Click to play again", CANVAS_WIDTH / 2, 540);
            }
        }

        function lerpColor(c1, c2, t) {
            return {
                r: Math.floor(c1.r + (c2.r - c1.r) * t),
                g: Math.floor(c1.g + (c2.g - c1.g) * t),
                b: Math.floor(c1.b + (c2.b - c1.b) * t)
            };
        }

        // ============================================================
        // GAME LOOP
        // ============================================================

        function gameLoop(currentTime) {
            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (game.game_phase === "PLAYING") {
                updatePhysics(delta);
                updateAtmosphere();
                checkWinCondition();

                // Update hint timer
                if (game.hint_text && !game.show_hint) {
                    game.hint_timer += delta;
                    if (game.hint_timer >= game.level_data.hint_delay) {
                        game.show_hint = true;
                    }
                }
            } else if (game.game_phase === "ENDING") {
                game.ending_timer += delta;
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // ============================================================
        // START GAME
        // ============================================================

        init();
    </script>
</body>
</html>
