<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eraser</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #2a2a2a;
            font-family: Georgia, serif;
        }
        #gameContainer {
            position: relative;
        }
        canvas {
            border: 1px solid #333;
            cursor: none;
        }
        #customCursor {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 2px solid rgba(139, 115, 85, 0.5);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
            background-color: rgba(232, 224, 204, 0.3);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="700"></canvas>
        <div id="customCursor"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const cursor = document.getElementById('customCursor');

        // Constants
        const WINDOW_WIDTH = 900;
        const WINDOW_HEIGHT = 700;
        const SCENE_AREA_HEIGHT = 500;
        const UI_AREA_HEIGHT = 200;
        const ERASER_RADIUS = 25;

        const COLORS = {
            background: '#F5F5DC',
            erased: '#E8E0CC',
            line: '#000000',
            uiText: '#666666',
            narration: '#333333',
            white: '#FFFFFF'
        };

        // Game state
        let gamePhase = 'INTRO';
        let currentSceneIndex = 0;
        let eraserMask = null;
        let totalScenePixels = 0;
        let erasedPixelCount = 0;
        let elementRemaining = {};
        let connectionScore = 0;
        let canAdvance = false;
        let isMouseDown = false;
        let introScreenIndex = 0;
        let sceneImages = [];

        // Intro screens
        const INTRO_SCREENS = [
            {
                lines: ["A hospital room.", "Late afternoon light."],
                duration: 3000,
                fontSize: 16,
                color: "#555555"
            },
            {
                lines: ["You sit beside your grandmother's bed.", "",
                        "She is 83 years old.", "She doesn't have much time left."],
                duration: 4000,
                fontSize: 16,
                color: "#555555"
            },
            {
                lines: ['"Grandma... tell me about Grandpa.', 'How did you two meet?"'],
                duration: 3000,
                fontSize: 18,
                color: "#333333",
                italic: true
            },
            {
                lines: ["She closes her eyes.", "", "She tries to remember."],
                duration: 3000,
                fontSize: 16,
                color: "#555555"
            },
            {
                lines: ["But fifty years is a long time.", "",
                        "Memory fades. Details blur.", "She cannot hold onto everything."],
                duration: 4000,
                fontSize: 15,
                color: "#666666"
            },
            {
                lines: ["What she tells you will depend", "on what she can still see."],
                duration: 3000,
                fontSize: 16,
                color: "#555555"
            }
        ];

        // Scene definitions
        const SCENES = [
            {
                name: "The Meeting",
                minKeep: 0.30,
                minErase: 0.50,
                elements: {
                    A: { polygon: [[200, 180], [280, 180], [280, 320], [200, 320]], description: "Elena" },
                    B: { polygon: [[400, 160], [480, 160], [480, 300], [400, 300]], description: "David" },
                    C: { polygon: [[650, 100], [800, 100], [800, 250], [650, 250]], description: "Rain" },
                    D: { polygon: [[180, 300], [260, 300], [260, 350], [180, 350]], description: "Notes" },
                    E: { polygon: [[100, 200], [150, 200], [150, 280], [100, 280]], description: "Students" },
                    F: { polygon: [[750, 50], [850, 50], [850, 120], [750, 120]], description: "Clock" }
                },
                narrationRules: [
                    { condition: (e) => e.A > 0.4 && e.B > 0.4, text: "I remember him looking at me. I was so nervous I pretended not to notice." },
                    { condition: (e) => e.A > 0.4 && e.B <= 0.4, text: "I was alone that day. So alone. I didn't know anyone." },
                    { condition: (e) => e.A <= 0.4 && e.B > 0.4, text: "There was a young man. I can picture his face but not where I was sitting." },
                    { condition: (e) => e.C > 0.4, text: "It was raining. I remember the rain." },
                    { condition: (e) => e.D > 0.4, text: "I was studying. Always studying." },
                    { condition: () => true, text: "It must have been an ordinary day. I can't picture it." }
                ]
            },
            {
                name: "The First Date",
                minKeep: 0.25,
                minErase: 0.55,
                elements: {
                    A: { polygon: [[250, 200], [450, 200], [450, 380], [250, 380]], description: "Elena and David" },
                    B: { polygon: [[300, 280], [400, 280], [400, 320], [300, 320]], description: "Coffee cups" },
                    C: { polygon: [[400, 260], [450, 260], [450, 300], [400, 300]], description: "Hand reaching" },
                    D: { polygon: [[340, 240], [360, 240], [360, 280], [340, 280]], description: "Flower" },
                    E: { polygon: [[100, 150], [180, 150], [180, 350], [100, 350]], description: "Waiter" },
                    F: { polygon: [[600, 100], [750, 100], [750, 300], [600, 300]], description: "Rain" }
                },
                narrationRules: [
                    { condition: (e) => e.A > 0.4 && e.C > 0.4, text: "He reached for my hand. I let him take it." },
                    { condition: (e) => e.A > 0.4 && e.C <= 0.4, text: "We talked for hours. Just talked." },
                    { condition: (e) => e.D > 0.4, text: "There was a flower. A small one. He said it reminded him of spring." },
                    { condition: (e) => e.B > 0.4, text: "I remember coffee. Bad coffee, actually. But we didn't care." },
                    { condition: (e) => e.F > 0.4, text: "Still raining. It rained so much that spring." },
                    { condition: (e) => e.A <= 0.4, text: "We must have gone somewhere. I wish I could see it." },
                    { condition: () => true, text: "The evening is a blur. But I know I was happy." }
                ]
            },
            {
                name: "The Proposal",
                minKeep: 0.25,
                minErase: 0.55,
                elements: {
                    A: { polygon: [[350, 250], [450, 250], [450, 380], [350, 380]], description: "David kneeling" },
                    B: { polygon: [[200, 180], [300, 180], [300, 280], [200, 280]], description: "Elena on bench" },
                    C: { polygon: [[380, 320], [420, 320], [420, 350], [380, 350]], description: "Ring box" },
                    D: { polygon: [[100, 380], [800, 380], [800, 450], [100, 450]], description: "Leaves" },
                    E: { polygon: [[650, 150], [750, 150], [750, 300], [650, 300]], description: "People walking" },
                    F: { polygon: [[550, 280], [650, 280], [650, 350], [550, 350]], description: "Dog" }
                },
                narrationRules: [
                    { condition: (e) => e.A > 0.4 && e.C > 0.4, text: "He knelt down. The ring was his grandmother's." },
                    { condition: (e) => e.A > 0.4 && e.C <= 0.4, text: "He asked me something. The words... I can't hear them anymore." },
                    { condition: (e) => e.B > 0.4, text: "I was crying. Happy tears. I think they were happy." },
                    { condition: (e) => e.D > 0.4, text: "It was autumn. The leaves were beautiful that year." },
                    { condition: (e) => e.F > 0.4, text: "There was a dog. Isn't that funny? A dog running past." },
                    { condition: (e) => e.A <= 0.4 && e.B <= 0.4, text: "He asked me somewhere outside. I said yes." },
                    { condition: () => true, text: "I know he asked. I know I answered. The rest is gone." }
                ]
            },
            {
                name: "The Difficulty",
                minKeep: 0.20,
                minErase: 0.60,
                elements: {
                    A: { polygon: [[150, 180], [250, 180], [250, 350], [150, 350]], description: "Elena at sink" },
                    B: { polygon: [[650, 150], [750, 150], [750, 350], [650, 350]], description: "David at door" },
                    C: { polygon: [[400, 380], [500, 380], [500, 430], [400, 430]], description: "Broken dish" },
                    D: { polygon: [[300, 100], [380, 100], [380, 180], [300, 180]], description: "Child's drawing" },
                    E: { polygon: [[100, 50], [250, 50], [250, 150], [100, 150]], description: "Night window" },
                    F: { polygon: [[350, 200], [550, 200], [550, 280], [350, 280]], description: "Dinner table" }
                },
                narrationRules: [
                    { condition: (e) => e.A > 0.4 && e.B > 0.4 && e.C > 0.4, text: "We fought. I don't remember why. Something broke." },
                    { condition: (e) => e.A > 0.4 && e.B > 0.4 && e.C <= 0.4, text: "We had hard times. Everyone does." },
                    { condition: (e) => e.A > 0.4 && e.B <= 0.4, text: "I was alone so often. Waiting." },
                    { condition: (e) => e.A <= 0.4 && e.B > 0.4, text: "He was always leaving. Or coming back. I confuse them now." },
                    { condition: (e) => e.C > 0.4, text: "Something broke. I can still hear it." },
                    { condition: (e) => e.D > 0.4, text: "The children. We stayed together for the children." },
                    { condition: (e) => e.A <= 0.4 && e.B <= 0.4, text: "That year is hazy. We got through it somehow." },
                    { condition: () => true, text: "There were hard years. I don't like to think about them." }
                ]
            },
            {
                name: "The End",
                minKeep: 0.20,
                minErase: 0.60,
                elements: {
                    A: { polygon: [[300, 200], [500, 200], [500, 350], [300, 350]], description: "David in bed" },
                    B: { polygon: [[500, 250], [600, 250], [600, 380], [500, 380]], description: "Elena holding hand" },
                    C: { polygon: [[650, 180], [750, 180], [750, 280], [650, 280]], description: "Heart monitor" },
                    D: { polygon: [[200, 280], [280, 280], [280, 360], [200, 360]], description: "Flowers" },
                    E: { polygon: [[250, 350], [330, 350], [330, 420], [250, 420]], description: "Photograph" },
                    F: { polygon: [[100, 80], [250, 80], [250, 200], [100, 200]], description: "Sunlight" }
                },
                narrationRules: [
                    { condition: (e) => e.A > 0.4 && e.B > 0.4, text: "I was with him. At the end, I was there." },
                    { condition: (e) => e.A > 0.4 && e.B <= 0.4, text: "He was so tired. So small in that bed." },
                    { condition: (e) => e.A <= 0.4 && e.B > 0.4, text: "I held onto something. I don't remember letting go." },
                    { condition: (e) => e.C > 0.4, text: "The sound stopped. It's the silence I remember." },
                    { condition: (e) => e.E > 0.4, text: "We were so young once. I looked at that photo every day." },
                    { condition: (e) => e.F > 0.4, text: "There was sunlight. He always loved the sun." },
                    { condition: (e) => e.A <= 0.4, text: "The room is empty now. In my mind, it's always empty." },
                    { condition: () => true, text: "It ended. Everything ends." }
                ]
            }
        ];

        // Initialize eraser mask
        function createEraserMask() {
            eraserMask = new Array(WINDOW_WIDTH);
            for (let x = 0; x < WINDOW_WIDTH; x++) {
                eraserMask[x] = new Array(SCENE_AREA_HEIGHT).fill(false);
            }
        }

        // Point in polygon check
        function pointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                if ((yi > y) !== (yj > y) && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Get pixels in polygon
        function getPixelsInPolygon(polygon) {
            const pixels = [];
            let minX = polygon[0][0], maxX = polygon[0][0];
            let minY = polygon[0][1], maxY = polygon[0][1];

            for (let point of polygon) {
                minX = Math.min(minX, point[0]);
                maxX = Math.max(maxX, point[0]);
                minY = Math.min(minY, point[1]);
                maxY = Math.max(maxY, point[1]);
            }

            for (let x = Math.floor(minX); x <= Math.ceil(maxX); x++) {
                for (let y = Math.floor(minY); y <= Math.ceil(maxY); y++) {
                    if (pointInPolygon(x, y, polygon)) {
                        pixels.push([x, y]);
                    }
                }
            }
            return pixels;
        }

        // Calculate element remaining percentage
        function calculateElementRemaining(element) {
            const pixels = getPixelsInPolygon(element.polygon);
            let erasedCount = 0;

            for (let [x, y] of pixels) {
                if (x >= 0 && x < WINDOW_WIDTH && y >= 0 && y < SCENE_AREA_HEIGHT) {
                    if (eraserMask[x][y]) {
                        erasedCount++;
                    }
                }
            }

            return pixels.length > 0 ? 1.0 - (erasedCount / pixels.length) : 1.0;
        }

        // Draw scene
        function drawScene(sceneIndex) {
            const scene = SCENES[sceneIndex];
            ctx.fillStyle = COLORS.line;
            ctx.strokeStyle = COLORS.line;
            ctx.lineWidth = 3;

            // Draw each element
            for (let elementKey in scene.elements) {
                const element = scene.elements[elementKey];
                const polygon = element.polygon;

                ctx.beginPath();
                ctx.moveTo(polygon[0][0], polygon[0][1]);
                for (let i = 1; i < polygon.length; i++) {
                    ctx.lineTo(polygon[i][0], polygon[i][1]);
                }
                ctx.closePath();
                ctx.fill();

                // Add descriptive sketch inside
                ctx.fillStyle = COLORS.background;
                ctx.font = '12px Georgia';
                ctx.textAlign = 'center';
                const centerX = polygon.reduce((sum, p) => sum + p[0], 0) / polygon.length;
                const centerY = polygon.reduce((sum, p) => sum + p[1], 0) / polygon.length;
                ctx.fillText(element.description, centerX, centerY);
                ctx.fillStyle = COLORS.line;
            }
        }

        // Apply eraser mask
        function applyEraserMask() {
            ctx.fillStyle = COLORS.erased;
            for (let x = 0; x < WINDOW_WIDTH; x++) {
                for (let y = 0; y < SCENE_AREA_HEIGHT; y++) {
                    if (eraserMask[x][y]) {
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
        }

        // Draw UI
        function drawUI() {
            const scene = SCENES[currentSceneIndex];
            const uiTop = SCENE_AREA_HEIGHT;

            // Separator line
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, uiTop);
            ctx.lineTo(WINDOW_WIDTH, uiTop);
            ctx.stroke();

            // Memory clarity meter
            const percentRemaining = 1.0 - (erasedPixelCount / totalScenePixels);
            const meterWidth = 200;
            const meterHeight = 20;
            const meterX = 50;
            const meterY = uiTop + 30;

            ctx.strokeStyle = '#666666';
            ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);

            ctx.fillStyle = '#8B7355';
            ctx.fillRect(meterX, meterY, meterWidth * percentRemaining, meterHeight);

            ctx.fillStyle = COLORS.uiText;
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Memory clarity: ${Math.round(percentRemaining * 100)}%`, meterX, meterY - 5);

            // Minimum marker
            const minKeepX = meterX + (meterWidth * scene.minKeep);
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(minKeepX, meterY);
            ctx.lineTo(minKeepX, meterY + meterHeight);
            ctx.stroke();

            // Instructions
            const percentErased = erasedPixelCount / totalScenePixels;
            ctx.textAlign = 'center';
            ctx.font = '16px Georgia';

            if (percentErased < scene.minErase) {
                ctx.fillStyle = '#666666';
                ctx.fillText("Let go of more to continue...", WINDOW_WIDTH / 2, uiTop + 100);
            } else if (canAdvance) {
                ctx.fillStyle = '#333333';
                ctx.fillRect(WINDOW_WIDTH / 2 - 80, uiTop + 80, 160, 40);
                ctx.fillStyle = COLORS.background;
                ctx.fillText("Continue â†’", WINDOW_WIDTH / 2, uiTop + 105);

                ctx.fillStyle = '#999999';
                ctx.font = '12px Arial';
                ctx.fillText("Click to continue", WINDOW_WIDTH / 2, uiTop + 140);
            }
        }

        // Handle erasing
        function handleErase(mouseX, mouseY) {
            if (gamePhase !== 'PLAYING') return;
            if (mouseY > SCENE_AREA_HEIGHT) return;

            const scene = SCENES[currentSceneIndex];
            let erasedThisFrame = 0;

            // Erase in circle around cursor
            for (let dx = -ERASER_RADIUS; dx <= ERASER_RADIUS; dx++) {
                for (let dy = -ERASER_RADIUS; dy <= ERASER_RADIUS; dy++) {
                    if (dx * dx + dy * dy <= ERASER_RADIUS * ERASER_RADIUS) {
                        const x = Math.floor(mouseX + dx);
                        const y = Math.floor(mouseY + dy);

                        if (x >= 0 && x < WINDOW_WIDTH && y >= 0 && y < SCENE_AREA_HEIGHT) {
                            if (!eraserMask[x][y]) {
                                // Check if erasing would violate minimum keep
                                const newRemaining = (totalScenePixels - erasedPixelCount - erasedThisFrame - 1) / totalScenePixels;
                                if (newRemaining >= scene.minKeep) {
                                    eraserMask[x][y] = true;
                                    erasedPixelCount++;
                                    erasedThisFrame++;
                                }
                            }
                        }
                    }
                }
            }

            // Update element remaining percentages
            for (let elementKey in scene.elements) {
                elementRemaining[elementKey] = calculateElementRemaining(scene.elements[elementKey]);
            }

            // Check advance conditions
            const percentErased = erasedPixelCount / totalScenePixels;
            canAdvance = percentErased >= scene.minErase;

            redraw();
        }

        // Redraw everything
        function redraw() {
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

            if (gamePhase === 'PLAYING') {
                drawScene(currentSceneIndex);
                applyEraserMask();
                drawUI();
            }
        }

        // Load scene
        function loadScene(sceneIndex) {
            currentSceneIndex = sceneIndex;
            createEraserMask();

            const scene = SCENES[sceneIndex];

            // Calculate total pixels in all elements
            totalScenePixels = 0;
            for (let elementKey in scene.elements) {
                const pixels = getPixelsInPolygon(scene.elements[elementKey].polygon);
                totalScenePixels += pixels.length;
            }

            erasedPixelCount = 0;
            elementRemaining = {};

            for (let elementKey in scene.elements) {
                elementRemaining[elementKey] = 1.0;
            }

            canAdvance = false;

            // Show scene title
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
            ctx.fillStyle = COLORS.narration;
            ctx.font = '24px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(scene.name, WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2);

            setTimeout(() => {
                gamePhase = 'PLAYING';
                redraw();
            }, 2000);
        }

        // Generate narration
        function generateNarration() {
            const scene = SCENES[currentSceneIndex];

            for (let rule of scene.narrationRules) {
                if (rule.condition(elementRemaining)) {
                    return rule.text;
                }
            }

            return "That time is hazy now. I can barely see it.";
        }

        // Show narration
        function showNarration() {
            gamePhase = 'NARRATING';

            // Calculate connection score
            if (currentSceneIndex !== 3) {
                if (elementRemaining.A > 0.4 && elementRemaining.B > 0.4) {
                    connectionScore++;
                }
            } else {
                if (elementRemaining.A > 0.4 && elementRemaining.B > 0.4 && elementRemaining.D > 0.4) {
                    connectionScore++;
                }
            }

            const narrationText = generateNarration();

            // Clear and show narration
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

            ctx.fillStyle = COLORS.narration;
            ctx.font = '18px Georgia';
            ctx.textAlign = 'center';

            // Word wrap
            const words = narrationText.split(' ');
            const lines = [];
            let currentLine = '';

            for (let word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                if (metrics.width > WINDOW_WIDTH - 100 && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            if (currentLine) lines.push(currentLine);

            const startY = WINDOW_HEIGHT / 2 - (lines.length * 15);
            lines.forEach((line, i) => {
                ctx.fillText(line, WINDOW_WIDTH / 2, startY + i * 35);
            });

            // Show continue prompt
            setTimeout(() => {
                ctx.fillStyle = '#999999';
                ctx.font = '14px Arial';
                ctx.fillText("[Click to continue]", WINDOW_WIDTH / 2, WINDOW_HEIGHT - 50);
                gamePhase = 'WAITING_NARRATION';
            }, 2000);
        }

        // Advance to next scene
        function advanceScene() {
            currentSceneIndex++;

            if (currentSceneIndex >= SCENES.length) {
                showEnding();
            } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
                setTimeout(() => loadScene(currentSceneIndex), 1000);
            }
        }

        // Show ending
        function showEnding() {
            gamePhase = 'ENDING';

            // Fade to black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

            let endingLines;
            if (connectionScore >= 4) {
                endingLines = [
                    "I had a good life. A happy life.",
                    "Thank you for asking me to remember.",
                    "",
                    "I think I'll rest now."
                ];
            } else if (connectionScore >= 2) {
                endingLines = [
                    "We did our best. Both of us.",
                    "Memory is strange. You hold onto such odd things.",
                    "",
                    "I hope I told it right."
                ];
            } else {
                endingLines = [
                    "Fifty years. Where did they go?",
                    "I wish I could see his face. Just once more.",
                    "",
                    "Was it like that? I'm not sure anymore."
                ];
            }

            let delay = 1000;
            const lineSpacing = 40;
            const startY = WINDOW_HEIGHT / 2 - (endingLines.length * lineSpacing) / 2;

            endingLines.forEach((line, i) => {
                setTimeout(() => {
                    if (line) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '18px Georgia';
                        ctx.textAlign = 'center';
                        ctx.fillText(line, WINDOW_WIDTH / 2, startY + i * lineSpacing);
                    }
                }, delay);
                delay += line ? 2500 : 2000;
            });

            setTimeout(() => {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

                setTimeout(() => {
                    ctx.fillStyle = '#CCCCCC';
                    ctx.font = '20px Georgia';
                    ctx.textAlign = 'center';
                    ctx.fillText("What we forget shapes who we become.", WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2);

                    setTimeout(() => {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

                        setTimeout(() => {
                            ctx.fillStyle = '#AAAAAA';
                            ctx.font = '16px Georgia';
                            ctx.fillText("Elena passed away three days later.", WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 - 20);

                            setTimeout(() => {
                                ctx.fillText("This is how you remember the story she told you.", WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 20);

                                setTimeout(() => {
                                    ctx.fillStyle = '#000000';
                                    ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
                                    ctx.fillStyle = '#666666';
                                    ctx.font = '24px Georgia';
                                    ctx.fillText("ERASER", WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 - 20);
                                    ctx.font = '14px Arial';
                                    ctx.fillStyle = '#444444';
                                    ctx.fillText("[Refresh to play again]", WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 20);
                                }, 5000);
                            }, 3000);
                        }, 1000);
                    }, 4000);
                }, 1000);
            }, delay);
        }

        // Show intro screen
        function showIntroScreen(index) {
            if (index < INTRO_SCREENS.length) {
                const screen = INTRO_SCREENS[index];
                ctx.fillStyle = COLORS.background;
                ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

                ctx.fillStyle = screen.color;
                ctx.font = `${screen.italic ? 'italic' : ''} ${screen.fontSize}px Georgia`;
                ctx.textAlign = 'center';

                const startY = WINDOW_HEIGHT / 2 - (screen.lines.length * 17);
                screen.lines.forEach((line, i) => {
                    if (line) {
                        ctx.fillText(line, WINDOW_WIDTH / 2, startY + i * 35);
                    }
                });

                setTimeout(() => {
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
                    setTimeout(() => showIntroScreen(index + 1), 500);
                }, screen.duration);
            } else {
                showTitleScreen();
            }
        }

        // Show title screen
        function showTitleScreen() {
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);

            ctx.fillStyle = '#333333';
            ctx.font = '32px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText("ERASER", WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 - 80);

            ctx.fillStyle = '#666666';
            ctx.font = '14px Georgia';
            const instructions = [
                "Click and drag to let memories fade.",
                "Some things must be forgotten to move on.",
                "What remains will become her story."
            ];

            instructions.forEach((line, i) => {
                ctx.fillText(line, WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + i * 28);
            });

            ctx.fillStyle = '#999999';
            ctx.font = '12px Arial';
            ctx.fillText("[Click to begin]", WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 120);

            gamePhase = 'TITLE';
        }

        // Mouse event handlers
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (gamePhase === 'TITLE') {
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
                setTimeout(() => loadScene(0), 1000);
            } else if (gamePhase === 'PLAYING') {
                if (canAdvance && mouseY > SCENE_AREA_HEIGHT + 60 && mouseY < SCENE_AREA_HEIGHT + 120) {
                    showNarration();
                } else {
                    handleErase(mouseX, mouseY);
                }
            } else if (gamePhase === 'WAITING_NARRATION') {
                advanceScene();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Update custom cursor
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';

            if (gamePhase === 'PLAYING') {
                cursor.style.display = 'block';
                if (isMouseDown) {
                    handleErase(mouseX, mouseY);
                }
            } else {
                cursor.style.display = 'none';
            }
        });

        canvas.addEventListener('mouseenter', () => {
            if (gamePhase === 'PLAYING') {
                cursor.style.display = 'block';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            cursor.style.display = 'none';
            isMouseDown = false;
        });

        // Start game
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
        setTimeout(() => showIntroScreen(0), 500);
    </script>
</body>
</html>
