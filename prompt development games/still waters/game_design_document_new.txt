================================================================================
                              STILL WATERS
                         A Game About Letting Go
                       Complete Design Document
================================================================================

## 1. TITLE & HOOK

Title: STILL WATERS

Hook: A game where your instinct to help is what's causing the harm.

Logline: You're trying to save a figure made of drifting letters—someone's last 
message to you—but every movement scatters the words further. Only by becoming 
still can you finally read what they wanted to say.

--------------------------------------------------------------------------------

## 2. CORE INSIGHT

Central Question: 
What if the most loving thing you can do is stop trying to fix things?

The Truth This Game Explores:
Grief, loss, and letting go are not problems to be solved. Our desperate need 
to DO something—to help, to hold on, to intervene—often prevents us from 
receiving what we need most: presence, witness, acceptance.

Why This Matters to a Human Player:
Everyone has experienced loss. Everyone has felt the frantic urge to "do 
something" when someone they love is hurting or leaving. This game creates a 
space where the player PHYSICALLY experiences how their helpful instincts can 
be counterproductive—not through text that tells them, but through mechanics 
that show them. The realization comes from within, not from without.

The Emotional Arc:
1. Confusion → "What's happening? What should I do?"
2. Instinct → "I need to catch these letters! I need to save this!"
3. Frustration → "Why isn't this working? It's getting worse!"
4. Suspicion → "Wait... am I making this worse?"
5. Surrender → "What if I just... stop?"
6. Understanding → "Oh. The message was there all along."

--------------------------------------------------------------------------------

## 3. MECHANIC-NARRATIVE INTEGRATION

PRIMARY MECHANIC:
You control a small cursor/marker on screen. Letters (which together form a 
meaningful message) float in the play area. The letters slowly drift outward 
from center, but at a manageable pace.

HERE'S THE TWIST:
Your movement creates "disturbance"—visualized as ripples or waves. This 
disturbance accelerates the drift of nearby letters. The faster you move, 
the more you scatter the words. Touching a letter doesn't "save" it—it 
knocks it away faster.

THE HIDDEN SOLUTION:
If you remain completely still, several things happen:
1. The letters slow their drift dramatically
2. They begin to arrange themselves into readable lines
3. A message becomes clear—a goodbye from someone who loved you
4. The game ends peacefully

THE TRAP:
The game gives NO instructions. Players will instinctively try to "catch" 
letters, chase them, gather them. This makes everything worse. The game 
counts on players' helpful instincts working against them.

WHAT THE PLAYER UNDERSTANDS BY THE END:
That their frantic attempts to hold on were preventing them from receiving 
what was freely given. The message was always there—they just needed to 
be still enough to see it.

Mechanical Metaphor Map:
- Player movement = Your desperate need to "do something"
- Scattered letters = Memories/meaning fragmenting under pressure  
- Stillness = Acceptance, presence, witness
- The readable message = What the person/moment was always trying to give you

--------------------------------------------------------------------------------

## 4. COMPLETE NARRATIVE CONTENT

THE MESSAGE (revealed when player is still):
The letters, when undisturbed, slowly arrange into this text:

    "I know you wanted to save me.
     But you couldn't.
     
     That's okay.
     
     What I needed was never saving.
     What I needed was
     
     someone to sit with me
     in the dark
     without trying
     to turn on the lights.
     
     Thank you for being here.
     
     You can let go now."

THE FAILED STATE (if player scatters all letters):
If the letters spread beyond the screen boundaries (too much movement), 
the screen slowly fades to black with only this text:

    "The words scattered before you could read them.
     But they were never really gone.
     
     Be still.
     
     [Press R to try again]"

This isn't a "game over"—it's a gentle redirection toward the insight.

OPENING TEXT (before gameplay):
Screen fades in from black with:

    "Someone left you a message.
     The words are drifting apart."

Then gameplay begins. No instructions. No tutorial.

--------------------------------------------------------------------------------

## 5. TECHNICAL SPECIFICATION

PLATFORM: Terminal (80x24 characters) OR simple 2D window (800x600 pixels)
IMPLEMENTATION LANGUAGE: Python (with curses) or JavaScript (with canvas)

DISPLAY SPECIFICATIONS:

Terminal Version:
- 80 columns x 24 rows
- Message letters displayed as bright/white characters
- Player cursor displayed as "◆" or "@" symbol  
- Disturbance ripples shown as "·" characters that fade
- Background is empty/black

2D Window Version:
- 800x600 pixel window
- Message letters: white, 24pt monospace font
- Player: small glowing circle (radius 8px), soft blue
- Ripples: concentric circles emanating from player when moving, fading
- Background: deep navy (#0a0a14)

INPUT:
- Arrow keys OR WASD for movement
- R key to restart
- ESC or Q to quit
- NO MOUSE INPUT (intentional—removes another avenue of "doing")

GAME STATE DATA STRUCTURE:

```
GameState:
    player_x: float (0.0 to 1.0, normalized position)
    player_y: float (0.0 to 1.0, normalized position)
    player_velocity_x: float
    player_velocity_y: float
    
    letters: List of Letter objects
    
    stillness_timer: float (seconds player has been still)
    disturbance_level: float (0.0 to 1.0, current chaos)
    
    phase: enum (INTRO, GAMEPLAY, RESOLUTION, SCATTERED)
    
    message_revealed_amount: float (0.0 to 1.0)

Letter:
    character: char
    x: float (current position)
    y: float (current position)
    home_x: float (where it "wants" to be—its position in the message)
    home_y: float
    velocity_x: float
    velocity_y: float
    target_line: int (which line of the message it belongs to)
    target_position: int (position within that line)
```

ASSETS NEEDED:
- None (all text-based)
- Optional: ambient drone sound (can be procedurally generated)

TIMING CONSTANTS:
```
INTRO_DURATION = 3.0 seconds
STILLNESS_THRESHOLD = 0.5 seconds (no input = "still")
STILLNESS_TO_REVEAL = 8.0 seconds (of being still to fully reveal message)
MAX_GAME_DURATION = 300.0 seconds (5 minutes, then force gentle ending)
LETTER_SCATTER_THRESHOLD = 2.5 (if average letter distance from home > this, scattered state)
```

PHYSICS CONSTANTS:
```
PLAYER_SPEED = 0.3 units/second
PLAYER_FRICTION = 0.85 per frame (smooth deceleration)
DISTURBANCE_RADIUS = 0.25 (how far player movement affects letters)
DISTURBANCE_STRENGTH = 0.15 (how much letters are pushed)
LETTER_DRIFT_SPEED = 0.01 (natural outward drift)
LETTER_HOME_PULL = 0.02 (how strongly letters want to return home when still)
LETTER_FRICTION = 0.98 per frame
```

--------------------------------------------------------------------------------

## 6. IMPLEMENTATION PSEUDOCODE

```
======================================
MAIN GAME LOOP
======================================

function main():
    initialize_display()
    game_state = create_initial_state()
    
    show_intro_text("Someone left you a message.\nThe words are drifting apart.")
    wait(3 seconds)
    clear_screen()
    
    game_state.phase = GAMEPLAY
    last_frame_time = current_time()
    
    while game_state.phase != QUIT:
        current_time = current_time()
        delta_time = current_time - last_frame_time
        last_frame_time = current_time
        
        input = get_input()  # Non-blocking
        
        if input == QUIT_KEY:
            game_state.phase = QUIT
            continue
        
        if input == RESTART_KEY:
            game_state = create_initial_state()
            game_state.phase = GAMEPLAY
            continue
        
        if game_state.phase == GAMEPLAY:
            update_gameplay(game_state, input, delta_time)
        elif game_state.phase == RESOLUTION:
            update_resolution(game_state, delta_time)
        elif game_state.phase == SCATTERED:
            update_scattered(game_state, delta_time)
        
        render(game_state)
        
        sleep_for_frame_rate(60 fps)
    
    cleanup_display()

======================================
STATE INITIALIZATION
======================================

function create_initial_state():
    state = new GameState()
    state.player_x = 0.5  # Center
    state.player_y = 0.5  # Center
    state.player_velocity_x = 0
    state.player_velocity_y = 0
    state.stillness_timer = 0
    state.disturbance_level = 0
    state.phase = GAMEPLAY
    state.message_revealed_amount = 0
    
    # The full message, broken into lines
    message_lines = [
        "I know you wanted to save me.",
        "But you couldn't.",
        "",
        "That's okay.",
        "",
        "What I needed was never saving.",
        "What I needed was",
        "",
        "someone to sit with me",
        "in the dark",
        "without trying",
        "to turn on the lights.",
        "",
        "Thank you for being here.",
        "",
        "You can let go now."
    ]
    
    state.letters = []
    
    # Calculate home positions for each letter (centered layout)
    center_y = 0.5
    line_height = 0.045
    start_y = center_y - (len(message_lines) * line_height / 2)
    
    for line_index, line in enumerate(message_lines):
        line_y = start_y + (line_index * line_height)
        line_width = len(line) * 0.012  # Character width in normalized coords
        start_x = 0.5 - (line_width / 2)
        
        for char_index, char in enumerate(line):
            if char == ' ':
                continue  # Don't create letter objects for spaces
            
            letter = new Letter()
            letter.character = char
            letter.home_x = start_x + (char_index * 0.012)
            letter.home_y = line_y
            letter.target_line = line_index
            letter.target_position = char_index
            
            # Start positions: slightly scattered from home
            letter.x = letter.home_x + random(-0.15, 0.15)
            letter.y = letter.home_y + random(-0.1, 0.1)
            letter.velocity_x = random(-0.005, 0.005)
            letter.velocity_y = random(-0.005, 0.005)
            
            state.letters.append(letter)
    
    return state

======================================
GAMEPLAY UPDATE
======================================

function update_gameplay(state, input, dt):
    # Process player input
    player_was_still = (state.player_velocity_x == 0 and state.player_velocity_y == 0)
    
    dx = 0
    dy = 0
    if input contains LEFT:  dx -= 1
    if input contains RIGHT: dx += 1
    if input contains UP:    dy -= 1
    if input contains DOWN:  dy += 1
    
    # Apply input to velocity
    if dx != 0 or dy != 0:
        # Normalize diagonal movement
        magnitude = sqrt(dx*dx + dy*dy)
        dx = dx / magnitude
        dy = dy / magnitude
        
        state.player_velocity_x += dx * PLAYER_SPEED * dt
        state.player_velocity_y += dy * PLAYER_SPEED * dt
    
    # Apply friction
    state.player_velocity_x *= PLAYER_FRICTION
    state.player_velocity_y *= PLAYER_FRICTION
    
    # Zero out tiny velocities
    if abs(state.player_velocity_x) < 0.001: state.player_velocity_x = 0
    if abs(state.player_velocity_y) < 0.001: state.player_velocity_y = 0
    
    # Update player position
    state.player_x += state.player_velocity_x * dt
    state.player_y += state.player_velocity_y * dt
    
    # Clamp player to bounds
    state.player_x = clamp(state.player_x, 0.05, 0.95)
    state.player_y = clamp(state.player_y, 0.05, 0.95)
    
    # Calculate current disturbance from player movement
    player_speed = sqrt(state.player_velocity_x^2 + state.player_velocity_y^2)
    current_disturbance = player_speed * 3.0  # Scale up for effect
    state.disturbance_level = lerp(state.disturbance_level, current_disturbance, 0.1)
    
    # Update stillness timer
    player_is_still = (player_speed < 0.01)
    if player_is_still:
        state.stillness_timer += dt
    else:
        state.stillness_timer = max(0, state.stillness_timer - dt * 2)  # Decay faster
    
    # Update each letter
    total_distance_from_home = 0
    
    for letter in state.letters:
        # Calculate distance from player
        dx_to_player = letter.x - state.player_x
        dy_to_player = letter.y - state.player_y
        dist_to_player = sqrt(dx_to_player^2 + dy_to_player^2)
        
        # Player disturbs nearby letters (pushes them away)
        if dist_to_player < DISTURBANCE_RADIUS and state.disturbance_level > 0.01:
            push_strength = (1 - dist_to_player / DISTURBANCE_RADIUS) * DISTURBANCE_STRENGTH * state.disturbance_level
            if dist_to_player > 0.001:
                letter.velocity_x += (dx_to_player / dist_to_player) * push_strength
                letter.velocity_y += (dy_to_player / dist_to_player) * push_strength
        
        # Natural drift (always pushing slightly outward from center)
        dx_from_center = letter.x - 0.5
        dy_from_center = letter.y - 0.5
        dist_from_center = sqrt(dx_from_center^2 + dy_from_center^2)
        if dist_from_center > 0.01:
            drift_x = (dx_from_center / dist_from_center) * LETTER_DRIFT_SPEED
            drift_y = (dy_from_center / dist_from_center) * LETTER_DRIFT_SPEED
            letter.velocity_x += drift_x * dt
            letter.velocity_y += drift_y * dt
        
        # If player is still, letters are pulled toward home
        if state.stillness_timer > STILLNESS_THRESHOLD:
            stillness_strength = min(1.0, (state.stillness_timer - STILLNESS_THRESHOLD) / 2.0)
            dx_to_home = letter.home_x - letter.x
            dy_to_home = letter.home_y - letter.y
            letter.velocity_x += dx_to_home * LETTER_HOME_PULL * stillness_strength
            letter.velocity_y += dy_to_home * LETTER_HOME_PULL * stillness_strength
        
        # Apply letter friction
        letter.velocity_x *= LETTER_FRICTION
        letter.velocity_y *= LETTER_FRICTION
        
        # Update letter position
        letter.x += letter.velocity_x
        letter.y += letter.velocity_y
        
        # Track how far letters are from home
        dx_from_home = letter.x - letter.home_x
        dy_from_home = letter.y - letter.home_y
        total_distance_from_home += sqrt(dx_from_home^2 + dy_from_home^2)
    
    # Calculate average distance from home
    avg_distance = total_distance_from_home / len(state.letters)
    
    # Check for scattered state (too much chaos)
    if avg_distance > LETTER_SCATTER_THRESHOLD:
        state.phase = SCATTERED
        return
    
    # Update message revealed amount based on stillness and letter positions
    if state.stillness_timer > STILLNESS_THRESHOLD:
        state.message_revealed_amount = min(1.0, 
            (state.stillness_timer - STILLNESS_THRESHOLD) / STILLNESS_TO_REVEAL)
    else:
        state.message_revealed_amount = max(0, state.message_revealed_amount - dt * 0.5)
    
    # Check for resolution (message fully revealed and letters near home)
    if state.message_revealed_amount >= 0.99 and avg_distance < 0.1:
        state.phase = RESOLUTION

======================================
RESOLUTION UPDATE (GOOD ENDING)
======================================

function update_resolution(state, dt):
    # Gentle fade, letters drift upward slowly
    for letter in state.letters:
        letter.velocity_y -= 0.001 * dt  # Gentle upward drift
        letter.x += letter.velocity_x
        letter.y += letter.velocity_y
    
    # After a few seconds, show final screen
    state.resolution_timer += dt
    if state.resolution_timer > 5.0:
        # Screen fades to gentle gradient, then shows:
        # "The words found their peace. So did you."
        # Then fade to black and end

======================================
SCATTERED UPDATE (FAILURE STATE)
======================================

function update_scattered(state, dt):
    # Letters continue drifting off screen
    for letter in state.letters:
        letter.x += letter.velocity_x
        letter.y += letter.velocity_y
    
    # Count letters still on screen
    visible_letters = count(letter for letter in state.letters 
                           if 0 < letter.x < 1 and 0 < letter.y < 1)
    
    # When most letters are gone, show the scattered message
    if visible_letters < len(state.letters) * 0.3:
        display_scattered_message()
        # "The words scattered before you could read them.
        #  But they were never really gone.
        #  Be still.
        #  [Press R to try again]"

======================================
RENDERING
======================================

function render(state):
    clear_screen()
    
    if state.phase == GAMEPLAY or state.phase == RESOLUTION:
        # Draw letters
        for letter in state.letters:
            screen_x = letter.x * SCREEN_WIDTH
            screen_y = letter.y * SCREEN_HEIGHT
            
            # Calculate opacity/visibility based on distance from home
            dx = letter.x - letter.home_x
            dy = letter.y - letter.home_y
            dist = sqrt(dx*dx + dy*dy)
            
            # Letters become more visible (brighter) as they approach home
            brightness = 1.0 - min(1.0, dist * 2)
            brightness = max(0.3, brightness)  # Minimum visibility
            
            draw_character(letter.character, screen_x, screen_y, brightness)
        
        # Draw player cursor
        player_screen_x = state.player_x * SCREEN_WIDTH
        player_screen_y = state.player_y * SCREEN_HEIGHT
        draw_cursor(player_screen_x, player_screen_y)
        
        # Draw disturbance ripples if player is moving
        if state.disturbance_level > 0.05:
            draw_ripples(player_screen_x, player_screen_y, state.disturbance_level)
        
        # If in resolution, overlay gentle fade
        if state.phase == RESOLUTION:
            draw_fade_overlay(state.resolution_timer / 5.0)
    
    elif state.phase == SCATTERED:
        # Draw remaining letters (drifting away)
        for letter in state.letters:
            if 0 < letter.x < 1 and 0 < letter.y < 1:
                screen_x = letter.x * SCREEN_WIDTH
                screen_y = letter.y * SCREEN_HEIGHT
                draw_character(letter.character, screen_x, screen_y, 0.5)
        
        # Draw the failure message if enough letters are gone
        if should_show_scattered_message(state):
            draw_centered_text([
                "The words scattered before you could read them.",
                "But they were never really gone.",
                "",
                "Be still.",
                "",
                "[Press R to try again]"
            ])
    
    refresh_screen()

======================================
TERMINAL-SPECIFIC RENDERING (if using curses/terminal)
======================================

function draw_character_terminal(char, x, y, brightness):
    # Convert normalized coords to terminal coords
    term_x = int(x * 80)
    term_y = int(y * 24)
    
    # Clamp to terminal bounds
    if term_x < 0 or term_x >= 80: return
    if term_y < 0 or term_y >= 24: return
    
    # Use different characters based on brightness (or color if available)
    if brightness > 0.7:
        attr = BRIGHT
    elif brightness > 0.4:
        attr = NORMAL
    else:
        attr = DIM
    
    terminal.addch(term_y, term_x, char, attr)

function draw_cursor_terminal(x, y):
    term_x = int(x * 80)
    term_y = int(y * 24)
    terminal.addch(term_y, term_x, '◆', BRIGHT | COLOR_CYAN)

function draw_ripples_terminal(x, y, intensity):
    # Draw dots around the cursor position
    term_x = int(x * 80)
    term_y = int(y * 24)
    
    radius = int(intensity * 5) + 1
    for angle in range(0, 360, 45):
        rx = int(term_x + cos(radians(angle)) * radius)
        ry = int(term_y + sin(radians(angle)) * radius * 0.5)  # Squash for terminal aspect
        if 0 <= rx < 80 and 0 <= ry < 24:
            terminal.addch(ry, rx, '·', DIM)

======================================
HELPER FUNCTIONS
======================================

function lerp(a, b, t):
    return a + (b - a) * t

function clamp(value, min_val, max_val):
    return max(min_val, min(max_val, value))

function random(min_val, max_val):
    return min_val + (random_float() * (max_val - min_val))
```

--------------------------------------------------------------------------------

## 7. EMOTIONAL PACING GUIDE

0:00 - 0:10   DISORIENTATION
              Player sees scattered letters, doesn't know what to do
              
0:10 - 1:00   INSTINCT TAKES OVER
              Player starts moving, chasing letters
              Letters scatter more, frustration builds
              
1:00 - 2:00   REALIZATION DAWNING  
              Player notices letters scatter when they move
              May try moving slowly—still not working
              
2:00 - 3:00   THE EXPERIMENT
              Player tries being still
              Notices letters slowly calming, drifting toward positions
              First glimpses of words forming
              
3:00 - 4:00   THE SURRENDER
              Player commits to stillness
              Message becomes readable
              Emotional impact of the words hits
              
4:00 - 5:00   RESOLUTION
              Full message visible
              Player sits with what they've read
              Gentle ending

--------------------------------------------------------------------------------

## 8. ALTERNATIVE ENDINGS SUMMARY

ENDING A - "THE MESSAGE" (Primary/Good)
Trigger: Player remains still long enough for message to fully form
Experience: Message is read, letters gently rise and fade, screen fades with
           "The words found their peace. So did you."
Emotional note: Catharsis, acceptance, release

ENDING B - "SCATTERED" (Failure/Redirect)  
Trigger: Player's movement pushes letters past the scatter threshold
Experience: Letters drift off screen, failure text appears, R to retry
Emotional note: Not punishing—an invitation to try again with new understanding
Important: This ending explicitly TELLS them to be still, so second playthrough 
          they know the "answer"—but knowing isn't the same as feeling it

ENDING C - "TIMEOUT" (Rare)
Trigger: 5 minutes pass without either ending
Experience: Screen slowly dims, text appears:
           "The words will wait. They always do.
            Come back when you're ready to be still."
           Then fade to black, game closes
Emotional note: Patient, not judgmental—mirrors the game's theme

--------------------------------------------------------------------------------

## 9. IMPLEMENTATION NOTES

CRITICAL DESIGN DECISIONS (Do Not Change):

1. NO INSTRUCTIONS - The lack of tutorial IS the design. Players must discover
   that stillness is the answer. Telling them defeats the purpose.

2. NO SOUND CUE FOR STILLNESS - Don't reward stillness with audio feedback.
   The reward is the message itself forming.

3. FAILURE TEXT REVEALS SOLUTION - This is intentional. The insight comes from
   EXPERIENCING the stillness, not from figuring out the puzzle.

4. PLAYER CURSOR MUST BE VISIBLE BUT NOT PROMINENT - The player should almost
   forget they have a cursor when still.

5. LETTER STARTING POSITIONS - Letters should start scattered but not 
   completely random—they should hint at word shapes without being readable.

OPTIONAL ENHANCEMENTS (If Time Permits):

- Ambient generative audio: low drone that becomes more harmonic when still
- Subtle particle effects behind letters as they settle into place
- Screen edge darkening when letters are scattered (vignette effect)
- Controller rumble support (rumble when disturbing letters, still when still)

--------------------------------------------------------------------------------

## 10. TESTING CHECKLIST

[ ] Player who doesn't read message can still find the ending through exploration
[ ] Message is readable at resolution (no overlapping letters)
[ ] Scattered state is reachable but not TOO easy to trigger
[ ] Stillness detection works correctly (complete stop, not just slow movement)
[ ] Letters don't cluster in corners or edges
[ ] Game runs at consistent frame rate
[ ] Restart works cleanly from any state
[ ] Terminal version works without color support (graceful degradation)
[ ] 5-minute timeout works
[ ] Emotional pacing feels right—not too fast to resolution, not too slow

--------------------------------------------------------------------------------

End of Document
================================================================================
